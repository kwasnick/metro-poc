<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Metro System Designer & Simulator</title>
  <style>
    body { font-family: sans-serif; margin:0; padding:0; }
    canvas { border: 1px solid #000; display: block; margin: 0 auto; }
    #controls { margin: 10px; }
    #controls > * { margin-right: 10px; }
    #counter { position: absolute; top: 10px; right: 10px; font-size: 18px; font-weight: bold; background: rgba(255,255,255,0.8); padding: 5px 10px; border: 1px solid #000; }
    #trainPopup {
      position: absolute;
      background: rgba(255,255,255,0.95);
      border: 1px solid #000;
      padding: 5px;
      display: none;
      pointer-events: none;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div id="controls">
    <label for="lineColorDropdown">Line Color:</label>
    <select id="lineColorDropdown">
      <option value="#ff0000" selected>Red</option>
      <option value="#0000ff">Blue</option>
      <option value="#00ff00">Green</option>
      <option value="#ffff00">Yellow</option>
      <option value="#800080">Purple</option>
      <option value="#ffa500">Orange</option>
      <option value="#00ffff">Cyan</option>
      <option value="#ff00ff">Magenta</option>
      <option value="#8b4513">Brown</option>
      <option value="#000000">Black</option>
    </select>
    <button id="newLineButton">New Line</button>
    <button id="deleteLineButton">Delete Line</button>
  </div>
  <div id="counter">Arrived: 0</div>
  <div id="trainPopup"></div>
  <p style="margin:10px;">
    <strong>How to use:</strong><br>
    • Click “New Line” then click on a station to begin drawing a new metro line. As you drag, if you pass near another station the route “snaps” to it. (A station already in the route won’t be added again—except if it’s the starting station, which will complete a loop if you have at least two stops.)<br>
    • In modify mode (by clicking an existing segment) drag from the pivot point. Dragging over one of the pivot’s endpoints will remove that stop (allowed even for loop lines or the final station in a non–loop) as long as the resulting route still has at least 2 stops (or 3 for loops); dragging over any other station inserts it between.<br>
    • To extend a non–circular line, small tabs appear at both endpoints. Click and drag a tab to a new station (using snapping) to extend the line at that end. (You can also drag from one tab to the opposite endpoint’s station to close the loop.)<br>
    • “Delete Line” removes every line whose color matches the current dropdown selection.<br>
    • Waiting commuters are drawn as small blue circles with a bold red “→ X” label (positioned at the top–right of the station) showing their destination. Mousing over one highlights its planned route.<br>
    • Passengers board trains – only the train heading toward the next station in their computed route is accepted. When that train arrives (at a transfer or final destination) the passenger disembarks immediately (triggering a “tada” burst and incrementing the global counter).<br>
    • You can mouse over any train to see a popup list of its onboard passengers.<br>
    • The simulation starts with 3 stations and gradually adds new stations (up to 26, labeled A–Z).<br>
    • A fixed, realistic city-map style background is shown behind the metro.
  </p>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <script>
    (function(){
      // ========= CONFIGURATION =========
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const acceleration = 0.0005;
      const maxSpeed = 0.05;
      const stationRadius = 15;
      const snapThreshold = 20;
      const trainWidth = 30, trainHeight = 15;
      const dwellTime = 2000;
      const commuterSpawnInterval = 3000;
      const initialStationCount = 3;
      const maxStationCount = 26;
      const minStationDist = 80;
      const stationAddInterval = 15000; // add new station every 15 sec
      const tabMargin = 10;
      const tabRadius = 6;

      // ========= GLOBAL STATE =========
      let stations = [];  // { id, x, y }
      let metroLines = []; // { id, color, stations: [...], trains: [], isLoop }
      /* activeLine is used when drawing or modifying a line.
         It now supports an "extend" mode for endpoints:
           editingMode: "extend"
           extendEnd: "start" or "end"
           extendCursor: current cursor pos for extension,
           extendCandidate: candidate station if snapped.
      */
      let activeLine = null;
      // Commuters: { id, currentStation, destinationStation, state:"waiting"|"inTrain", route:[{line, from, to}] }
      let commuters = [];
      let nextLineId = 1, nextTrainId = 1, nextCommuterId = 1;
      let arrivedCount = 0;
      let arrivalEffects = []; // { x, y, startTime }
      let hoveredCommuter = null;
      let hoveredTrain = null; // for train popup
      const trainPopup = document.getElementById('trainPopup');

      // ========= UI ELEMENTS =========
      const lineColorDropdown = document.getElementById('lineColorDropdown');
      const newLineButton = document.getElementById('newLineButton');
      const deleteLineButton = document.getElementById('deleteLineButton');
      const counterDiv = document.getElementById('counter');

      newLineButton.addEventListener('click', () => {
        if(activeLine) return;
        activeLine = {
          id: nextLineId++,
          color: lineColorDropdown.value,
          stations: [],
          trains: [],
          editingMode: "new"
        };
      });
      deleteLineButton.addEventListener('click', () => {
        metroLines = metroLines.filter(line => line.color !== lineColorDropdown.value);
      });

      // ========= STATION MANAGEMENT =========
      const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      function initStations(){
        for(let i = 0; i < initialStationCount; i++){
          addNewStation();
        }
      }
      function addNewStation(){
        if(stations.length >= maxStationCount) return;
        let newLetter = letters[stations.length];
        let valid = false, s, attempts = 0;
        while(!valid && attempts < 1000){
          s = {
            id: newLetter,
            x: Math.random()*(canvas.width-80) + 40,
            y: Math.random()*(canvas.height-80) + 40
          };
          valid = stations.every(st => distance(st.x, st.y, s.x, s.y) >= minStationDist);
          attempts++;
        }
        if(valid) stations.push(s);
      }
      setInterval(addNewStation, stationAddInterval);

      // ========= OFFSCREEN BACKGROUND (Saved) =========
      const bgCanvas = document.createElement("canvas");
      bgCanvas.width = canvas.width;
      bgCanvas.height = canvas.height;
      const bgCtx = bgCanvas.getContext("2d");
      function rectanglesOverlap(r1, r2) {
        return !(
          r2.x >= r1.x + r1.width ||
          r2.x + r2.width <= r1.x ||
          r2.y >= r1.y + r1.height ||
          r2.y + r2.height <= r1.y
        );
      }
      function createBackground(){
        let gridSpacing = 50;
        bgCtx.save();
        bgCtx.strokeStyle = "#e0e0e0";
        bgCtx.lineWidth = 1;
        for(let x = 0; x <= bgCanvas.width; x += gridSpacing){
          bgCtx.beginPath();
          bgCtx.moveTo(x, 0);
          bgCtx.lineTo(x, bgCanvas.height);
          bgCtx.stroke();
        }
        for(let y = 0; y <= bgCanvas.height; y += gridSpacing){
          bgCtx.beginPath();
          bgCtx.moveTo(0, y);
          bgCtx.lineTo(bgCanvas.width, y);
          bgCtx.stroke();
        }
        const placedRects = [];
        const maxRects = 25;
        let attempts = 0;
        const maxAttempts = maxRects * 10;
        while(placedRects.length < maxRects && attempts < maxAttempts) {
          let bx = Math.random() * bgCanvas.width;
          let by = Math.random() * bgCanvas.height;
          let bWidth = 40 + Math.random() * 60;
          let bHeight = 40 + Math.random() * 60;
          if(bx + bWidth > bgCanvas.width) bx = bgCanvas.width - bWidth;
          if(by + bHeight > bgCanvas.height) by = bgCanvas.height - bHeight;
          const newRect = { x: bx, y: by, width: bWidth, height: bHeight };
          let overlap = placedRects.some(rect => rectanglesOverlap(newRect, rect));
          if (!overlap) {
            placedRects.push(newRect);
          }
          attempts++;
        }
        placedRects.forEach(rect => {
          bgCtx.fillStyle = "rgba(200,200,200,0.3)";
          bgCtx.fillRect(rect.x, rect.y, rect.width, rect.height);
        });
        bgCtx.restore();
      }
      createBackground();

      // ========= HELPER FUNCTIONS =========
      function distance(x1, y1, x2, y2){
        return Math.hypot(x2-x1, y2-y1);
      }
      function getStationAt(x, y){
        for(let s of stations){
          if(distance(x, y, s.x, s.y) < stationRadius) return s;
        }
        return null;
      }
      function getSnappedStation(x, y){
        for(let s of stations){
          if(distance(x, y, s.x, s.y) < snapThreshold) return s;
        }
        return null;
      }
      function getLineSegmentAt(x, y){
        for(let line of metroLines){
          for(let i = 0; i < line.stations.length - 1; i++){
            let a = line.stations[i], b = line.stations[i+1];
            let d = distanceToSegment(x, y, a.x, a.y, b.x, b.y);
            if(d < 5) return { line: line, segmentIndex: i };
          }
        }
        return null;
      }
      function distanceToSegment(px, py, x1, y1, x2, y2){
        const l2 = Math.pow(distance(x1, y1, x2, y2), 2);
        if(l2 === 0) return distance(px, py, x1, y1);
        let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2;
        t = Math.max(0, Math.min(1, t));
        return distance(px, py, x1 + t*(x2-x1), y1 + t*(y2-y1));
      }
      function computeTravelTime(d){
        const t_acc = maxSpeed / acceleration;
        const d_acc = 0.5 * acceleration * t_acc * t_acc;
        if(d >= 2 * d_acc){
          let t_cruise = (d - 2 * d_acc) / maxSpeed;
          return t_acc + t_cruise + t_acc;
        } else {
          return 2 * Math.sqrt(d / acceleration);
        }
      }
      function darkenColor(hex, factor) {
        let r = parseInt(hex.slice(1, 3), 16);
        let g = parseInt(hex.slice(3, 5), 16);
        let b = parseInt(hex.slice(5, 7), 16);
        r = Math.floor(r * factor);
        g = Math.floor(g * factor);
        b = Math.floor(b * factor);
        return "#" +
          ("0" + r.toString(16)).slice(-2) +
          ("0" + g.toString(16)).slice(-2) +
          ("0" + b.toString(16)).slice(-2);
      }

      // ========= ENDPOINT EXTENSION FUNCTIONS =========
      function computeTabPosition(line, endpointType){
        let tab = { x: 0, y: 0 };
        if(line.stations.length < 2) return tab;
        if(endpointType === "end"){
          let last = line.stations[line.stations.length-1];
          let prev = line.stations[line.stations.length-2];
          let dx = last.x - prev.x, dy = last.y - prev.y;
          let len = Math.sqrt(dx*dx+dy*dy);
          let dirX = dx/len, dirY = dy/len;
          tab.x = last.x + dirX * (stationRadius + tabMargin);
          tab.y = last.y + dirY * (stationRadius + tabMargin);
        } else if(endpointType === "start"){
          let first = line.stations[0];
          let next = line.stations[1];
          let dx = first.x - next.x, dy = first.y - next.y;
          let len = Math.sqrt(dx*dx+dy*dy);
          let dirX = dx/len, dirY = dy/len;
          tab.x = first.x + dirX * (stationRadius + tabMargin);
          tab.y = first.y + dirY * (stationRadius + tabMargin);
        }
        return tab;
      }

      // ========= MOUSE EVENT HANDLING =========
      let isDragging = false;
      let currentMousePos = { x: 0, y: 0 };
      
      canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        let x = e.clientX - rect.left;
        let y = e.clientY - rect.top;
        if(!activeLine){
          let clickedTab = null;
          let extendEnd = null;
          for(let line of metroLines){
            if(line.isLoop) continue;
            let tabStart = computeTabPosition(line, "start");
            let tabEnd = computeTabPosition(line, "end");
            if(distance(x, y, tabStart.x, tabStart.y) < 8){
              clickedTab = line;
              extendEnd = "start";
              break;
            } else if(distance(x, y, tabEnd.x, tabEnd.y) < 8){
              clickedTab = line;
              extendEnd = "end";
              break;
            }
          }
          if(clickedTab){
            activeLine = clickedTab;
            activeLine.editingMode = "extend";
            activeLine.extendEnd = extendEnd;
            activeLine.extendCursor = { x, y };
            activeLine.extendCandidate = null;
            isDragging = true;
            return;
          }
        }
        if(!activeLine){
          let segInfo = getLineSegmentAt(x, y);
          if(segInfo){
            activeLine = segInfo.line;
            activeLine.editingMode = "modify";
            activeLine.modifySegmentIndex = segInfo.segmentIndex;
            activeLine.originalStations = activeLine.stations.slice();
            activeLine.modifyCursor = { x, y };
            activeLine.modifyCandidate = null;
          }
        } else if(activeLine.editingMode === "new"){
          if(activeLine.stations.length === 0){
            let s = getStationAt(x, y);
            if(s) activeLine.stations.push(s);
          }
        }
        isDragging = true;
      });
      
      canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        currentMousePos.x = e.clientX - rect.left;
        currentMousePos.y = e.clientY - rect.top;
        
        if(activeLine && isDragging){
          if(activeLine.editingMode === "new"){
            let snapped = getSnappedStation(currentMousePos.x, currentMousePos.y);
            if(snapped){
              let arr = activeLine.stations;
              if(snapped.id === arr[0].id && arr.length >= 2){
                if(arr[arr.length-1].id !== snapped.id) arr.push(snapped);
              } else {
                if(arr.length > 1 && arr[arr.length-2].id === snapped.id){
                  arr.pop();
                } else if(arr.some(s => s.id === snapped.id)){
                  // Do nothing.
                } else {
                  arr.push(snapped);
                }
              }
            }
          } else if(activeLine.editingMode === "modify"){
            let candidate = getSnappedStation(currentMousePos.x, currentMousePos.y);
            if(candidate){
              activeLine.modifyCursor = { x: candidate.x, y: candidate.y };
              activeLine.modifyCandidate = candidate;
            } else {
              activeLine.modifyCursor = { x: currentMousePos.x, y: currentMousePos.y };
              activeLine.modifyCandidate = null;
            }
          } else if(activeLine.editingMode === "extend"){
            let candidate = getSnappedStation(currentMousePos.x, currentMousePos.y);
            if(candidate){
              activeLine.extendCursor = { x: candidate.x, y: candidate.y };
              activeLine.extendCandidate = candidate;
            } else {
              activeLine.extendCursor = { x: currentMousePos.x, y: currentMousePos.y };
              activeLine.extendCandidate = null;
            }
          }
        }
        hoveredCommuter = null;
        let waitingByStation = {};
        for(let commuter of commuters){
          if(commuter.state === "waiting"){
            let id = commuter.currentStation.id;
            if(!waitingByStation[id]) waitingByStation[id] = [];
            waitingByStation[id].push(commuter);
          }
        }
        for(let stationId in waitingByStation){
          let group = waitingByStation[stationId];
          group.sort((a, b) => a.id - b.id);
          let station = stations.find(s => s.id === stationId);
          let baseX = station.x + stationRadius + 5;
          let baseY = station.y - stationRadius - 5;
          let gap = 12;
          for(let i = 0; i < group.length; i++){
            let pos = { x: baseX, y: baseY - i * gap };
            if(distance(currentMousePos.x, currentMousePos.y, pos.x, pos.y) < 8){
              hoveredCommuter = group[i];
              break;
            }
          }
          if(hoveredCommuter) break;
        }
      });
      
      canvas.addEventListener('mouseup', (e) => {
        isDragging = false;
        if(activeLine){
          if(activeLine.editingMode === "modify"){
            let idx = activeLine.modifySegmentIndex;
            let X = activeLine.originalStations[idx];
            let Y = activeLine.originalStations[idx+1];
            let minStations = activeLine.isLoop ? 3 : 2;
            if(activeLine.modifyCandidate){
              if((activeLine.modifyCandidate.id === X.id || activeLine.modifyCandidate.id === Y.id) && activeLine.originalStations.length > minStations){
                activeLine.stations = activeLine.originalStations.slice();
                if(activeLine.modifyCandidate.id === X.id){
                  activeLine.stations.splice(idx, 1);
                } else {
                  activeLine.stations.splice(idx+1, 1);
                }
              } else if(activeLine.modifyCandidate.id !== X.id && activeLine.modifyCandidate.id !== Y.id){
                if(!activeLine.originalStations.some(s => s.id === activeLine.modifyCandidate.id)){
                  activeLine.stations = activeLine.originalStations.slice();
                  activeLine.stations.splice(idx+1, 0, activeLine.modifyCandidate);
                } else {
                  activeLine.stations = activeLine.originalStations.slice();
                }
              } else {
                activeLine.stations = activeLine.originalStations.slice();
              }
            }
            activeLine.editingMode = "new";
            activeLine = null;
          } else if(activeLine.editingMode === "extend"){
            if(activeLine.extendCandidate) {
              // If extend candidate equals the opposite endpoint, close the loop.
              if(activeLine.extendEnd === "end"){
                if(activeLine.extendCandidate.id === activeLine.stations[0].id && activeLine.stations.length >= 2){
                  activeLine.stations.push(activeLine.extendCandidate);
                  activeLine.isLoop = true;
                } else if(!activeLine.stations.some(s => s.id === activeLine.extendCandidate.id)) {
                  activeLine.stations.push(activeLine.extendCandidate);
                }
              } else if(activeLine.extendEnd === "start"){
                if(activeLine.extendCandidate.id === activeLine.stations[activeLine.stations.length - 1].id && activeLine.stations.length >= 2){
                  activeLine.stations.unshift(activeLine.extendCandidate);
                  activeLine.isLoop = true;
                } else if(!activeLine.stations.some(s => s.id === activeLine.extendCandidate.id)) {
                  activeLine.stations.unshift(activeLine.extendCandidate);
                }
              }
            }
            activeLine = null;
          }
        }
      });
      
      canvas.addEventListener('dblclick', (e) => {
        if(activeLine && activeLine.editingMode === "new"){
          if(activeLine.stations.length >= 2){
            if(activeLine.stations[0].id === activeLine.stations[activeLine.stations.length-1].id && activeLine.stations.length >= 3){
              activeLine.isLoop = true;
            } else {
              activeLine.isLoop = false;
            }
            metroLines.push(activeLine);
            spawnDefaultTrains(activeLine);
          }
          activeLine = null;
        }
      });
      
      // ========= DRAWING ENDPOINT TABS =========
      function drawEndpointTabs(){
        metroLines.forEach(line => {
          if(line.isLoop || line.stations.length < 2) return;
          let startTab = computeTabPosition(line, "start");
          let endTab = computeTabPosition(line, "end");
          ctx.save();
          ctx.fillStyle = line.color;
          ctx.beginPath();
          ctx.arc(startTab.x, startTab.y, tabRadius, 0, 2*Math.PI);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(endTab.x, endTab.y, tabRadius, 0, 2*Math.PI);
          ctx.fill();
          ctx.restore();
        });
      }
      
      // ========= TRAIN SIMULATION =========
      function spawnDefaultTrains(line){
        line.trains = [];
        let now = performance.now();
        if(!line.isLoop){
          line.trains.push({
            id: nextTrainId++,
            line: line,
            direction: 1,
            currentSegment: 0,
            progress: 0,
            state: "dwell",
            dwellStart: now,
            travelTime: 0,
            onboard: [],
            originalSegment: null
          });
          line.trains.push({
            id: nextTrainId++,
            line: line,
            direction: -1,
            currentSegment: line.stations.length - 2,
            progress: 0,
            state: "dwell",
            dwellStart: now,
            travelTime: 0,
            onboard: [],
            originalSegment: null
          });
        } else {
          let idx1 = 0;
          let idx2 = Math.floor((line.stations.length - 1) / 2);
          line.trains.push({
            id: nextTrainId++,
            line: line,
            direction: 1,
            currentSegment: idx1,
            progress: 0,
            state: "dwell",
            dwellStart: now,
            travelTime: 0,
            onboard: [],
            originalSegment: null
          });
          line.trains.push({
            id: nextTrainId++,
            line: line,
            direction: -1,
            currentSegment: idx2,
            progress: 0,
            state: "dwell",
            dwellStart: now,
            travelTime: 0,
            onboard: [],
            originalSegment: null
          });
        }
      }
      
      function updateTrains(now){
        for(let line of metroLines){
          if(line.stations.length < 2) continue;
          for(let train of line.trains){
            if(train.currentSegment < 0) train.currentSegment = 0;
            if(train.currentSegment > line.stations.length - 2) train.currentSegment = line.stations.length - 2;
            let from, to;
            if(train.direction === 1){
              from = line.stations[train.currentSegment];
              to = line.stations[train.currentSegment+1];
            } else {
              from = line.stations[train.currentSegment+1];
              to = line.stations[train.currentSegment];
            }
            // If train just departed from dwell, store its original segment.
            if(train.state === "dwell" && now - train.dwellStart >= dwellTime){
              let segLength = distance(from.x, from.y, to.x, to.y);
              train.travelTime = computeTravelTime(segLength);
              train.state = "moving";
              train.departureTime = now;
              train.originalSegment = { from: { ...from }, to: { ...to }, travelTime: train.travelTime };
            }
            if(train.state === "moving"){
              let elapsed = now - train.departureTime;
              let p = elapsed / train.travelTime;
              let ease = 0.5 - 0.5 * Math.cos(Math.PI * Math.min(p, 1));
              train.progress = ease;
              // Compute position using originalSegment if it exists.
              let segFrom = train.originalSegment ? train.originalSegment.from : from;
              let segTo = train.originalSegment ? train.originalSegment.to : to;
              let dx = segTo.x - segFrom.x, dy = segTo.y - segFrom.y;
              let x = segFrom.x + dx * ease;
              let y = segFrom.y + dy * ease;
              // (Train drawing uses these computed x,y below.)
              // When movement is complete:
              if(p >= 1){
                let arrivalStation = train.originalSegment ? train.originalSegment.to : to;
                train.onboard.forEach(commuter => {
                  if(commuter.route && commuter.route.length > 0 && commuter.route[0].to.id === arrivalStation.id){
                    commuter.currentStation = arrivalStation;
                    commuter.route.shift();
                    if(commuter.destinationStation.id === arrivalStation.id){
                      commuter.arrived = true;
                      arrivedCount++;
                      arrivalEffects.push({ x: arrivalStation.x, y: arrivalStation.y, startTime: now });
                    } else {
                      commuter.state = "waiting";
                    }
                  }
                });
                train.onboard = [];
                // After finishing, clear originalSegment so future movements use the current line.
                train.originalSegment = null;
                if(!line.isLoop){
                  if(train.direction === 1 && train.currentSegment === line.stations.length - 2){
                    train.direction = -1;
                  } else if(train.direction === -1 && train.currentSegment === 0){
                    train.direction = 1;
                  } else {
                    train.currentSegment += train.direction;
                  }
                } else {
                  train.currentSegment = (train.currentSegment + train.direction) % (line.stations.length - 1);
                  if(train.currentSegment < 0) train.currentSegment += (line.stations.length - 1);
                }
                train.state = "dwell";
                train.dwellStart = now;
                train.progress = 0;
              }
            }
          }
        }
      }
      
      // ========= COMMUTER SIMULATION =========
      function buildGraph(){
        let graph = {};
        for(let s of stations) graph[s.id] = [];
        for(let line of metroLines){
          for(let i = 0; i < line.stations.length - 1; i++){
            let a = line.stations[i], b = line.stations[i+1];
            graph[a.id].push({ station: b, line: line });
            graph[b.id].push({ station: a, line: line });
          }
        }
        return graph;
      }
      function computeRoute(start, goal){
        let graph = buildGraph();
        let queue = [ start ];
        let visited = {};
        visited[start.id] = null;
        while(queue.length){
          let current = queue.shift();
          if(current === goal) break;
          for(let edge of graph[current.id]){
            if(!(edge.station.id in visited)){
              visited[edge.station.id] = { from: current, line: edge.line };
              queue.push(edge.station);
            }
          }
        }
        if(!(goal.id in visited)) return null;
        let route = [];
        let cur = goal;
        while(cur !== start){
          let info = visited[cur.id];
          route.unshift({ from: info.from, to: cur, line: info.line });
          cur = info.from;
        }
        return route;
      }
      function spawnCommuter(){
        if(stations.length < 2) return;
        let start = stations[Math.floor(Math.random()*stations.length)];
        let dest;
        do { dest = stations[Math.floor(Math.random()*stations.length)]; } while(dest === start);
        let route = computeRoute(start, dest);
        let commuter = {
          id: nextCommuterId++,
          currentStation: start,
          destinationStation: dest,
          state: "waiting",
          route: route
        };
        commuters.push(commuter);
      }
      function updateCommuters(now){
        for(let commuter of commuters){
          if(commuter.state === "waiting"){
            if(commuter.currentStation.id === commuter.destinationStation.id){
              commuter.arrived = true;
              arrivedCount++;
              arrivalEffects.push({ x: commuter.currentStation.x, y: commuter.currentStation.y, startTime: now });
              continue;
            }
            commuter.route = computeRoute(commuter.currentStation, commuter.destinationStation);
            if(commuter.route && commuter.route.length > 0){
              let seg = commuter.route[0];
              let candidate = seg.line.trains.find(train => {
                if(train.state !== "dwell") return false;
                let posStation = (train.direction === 1) ? train.line.stations[train.currentSegment] : train.line.stations[train.currentSegment+1];
                if(posStation.id !== commuter.currentStation.id) return false;
                if(train.direction === 1){
                  return train.line.stations[train.currentSegment+1].id === seg.to.id;
                } else {
                  return train.line.stations[train.currentSegment].id === seg.to.id;
                }
              });
              if(candidate){
                commuter.state = "inTrain";
                candidate.onboard = candidate.onboard || [];
                candidate.onboard.push(commuter);
              }
            }
          }
        }
        commuters = commuters.filter(c => !c.arrived && c.currentStation.id !== c.destinationStation.id);
        counterDiv.textContent = "Arrived: " + arrivedCount;
      }
      
      // ========= DRAWING FUNCTIONS =========
      function getSegmentOffset(line, segmentIndex){
        let a = line.stations[segmentIndex], b = line.stations[segmentIndex+1];
        let sameSegmentLines = metroLines.filter(l => {
          for(let i = 0; i < l.stations.length - 1; i++){
            let p = l.stations[i], q = l.stations[i+1];
            if((p.id === a.id && q.id === b.id) || (p.id === b.id && q.id === a.id)) return true;
          }
          return false;
        });
        sameSegmentLines.sort((l1, l2) => l1.id - l2.id);
        let idx = sameSegmentLines.findIndex(l => l.id === line.id);
        let count = sameSegmentLines.length;
        let offsetDistance = 10;
        let offset = (count % 2 === 1)
          ? (idx - Math.floor(count/2)) * offsetDistance
          : (idx - count/2 + 0.5) * offsetDistance;
        return offset;
      }
      function drawStations(){
        for(let s of stations){
          ctx.beginPath();
          ctx.arc(s.x, s.y, stationRadius, 0, 2*Math.PI);
          ctx.fillStyle = "#FFF";
          ctx.fill();
          ctx.strokeStyle = "#000";
          ctx.stroke();
          ctx.fillStyle = "#000";
          ctx.font = "12px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(s.id, s.x, s.y);
        }
      }
      function drawMetroLines(){
        for(let line of metroLines){
          ctx.beginPath();
          ctx.lineWidth = 4;
          ctx.strokeStyle = line.color;
          for(let i = 0; i < line.stations.length - 1; i++){
            let s1 = line.stations[i], s2 = line.stations[i+1];
            let offset = getSegmentOffset(line, i);
            let dx = s2.x - s1.x, dy = s2.y - s1.y;
            let len = Math.sqrt(dx*dx + dy*dy);
            let offX = -dy/len * offset;
            let offY = dx/len * offset;
            let startX = s1.x + offX;
            let startY = s1.y + offY;
            let endX = s2.x + offX;
            let endY = s2.y + offY;
            if(i === 0) ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
          }
          ctx.stroke();
          ctx.lineWidth = 2;
          if(!line.isLoop && line.stations.length >= 2){
            let startTab = computeTabPosition(line, "start");
            let endTab = computeTabPosition(line, "end");
            ctx.save();
            ctx.fillStyle = line.color;
            ctx.beginPath();
            ctx.arc(startTab.x, startTab.y, tabRadius, 0, 2*Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(endTab.x, endTab.y, tabRadius, 0, 2*Math.PI);
            ctx.fill();
            ctx.restore();
          }
        }
      }
      function drawActiveLine(){
        if(activeLine){
          if(activeLine.editingMode === "new"){
            ctx.beginPath();
            ctx.lineWidth = 4;
            ctx.strokeStyle = activeLine.color;
            for(let i = 0; i < activeLine.stations.length; i++){
              let s = activeLine.stations[i];
              if(i === 0) ctx.moveTo(s.x, s.y);
              else ctx.lineTo(s.x, s.y);
            }
            if(activeLine.stations.length > 0){
              ctx.lineTo(currentMousePos.x, currentMousePos.y);
            }
            ctx.stroke();
            ctx.lineWidth = 2;
          } else if(activeLine.editingMode === "modify"){
            ctx.save();
            ctx.globalAlpha = 0.3;
            ctx.beginPath();
            ctx.strokeStyle = activeLine.color;
            for(let i = 0; i < activeLine.originalStations.length; i++){
              let s = activeLine.originalStations[i];
              if(i === 0) ctx.moveTo(s.x, s.y);
              else ctx.lineTo(s.x, s.y);
            }
            ctx.stroke();
            ctx.restore();
            let tempStations = activeLine.originalStations.slice();
            let idx = activeLine.modifySegmentIndex;
            tempStations.splice(idx+1, 0, activeLine.modifyCursor);
            ctx.beginPath();
            ctx.lineWidth = 4;
            ctx.strokeStyle = activeLine.color;
            for(let i = 0; i < tempStations.length; i++){
              let p = tempStations[i];
              if(i === 0) ctx.moveTo(p.x, p.y);
              else ctx.lineTo(p.x, p.y);
            }
            ctx.stroke();
            ctx.lineWidth = 2;
          } else if(activeLine.editingMode === "extend"){
            let endpoint;
            if(activeLine.extendEnd === "end"){
              endpoint = activeLine.stations[activeLine.stations.length-1];
            } else {
              endpoint = activeLine.stations[0];
            }
            ctx.save();
            ctx.strokeStyle = activeLine.color;
            ctx.lineWidth = 4;
            ctx.setLineDash([5,5]);
            ctx.beginPath();
            ctx.moveTo(endpoint.x, endpoint.y);
            ctx.lineTo(activeLine.extendCursor.x, activeLine.extendCursor.y);
            ctx.stroke();
            ctx.restore();
            ctx.lineWidth = 2;
          }
        }
      }
      function drawTrains(){
        hoveredTrain = null;
        for(let line of metroLines){
          for(let train of line.trains){
            let segFrom, segTo;
            if(train.state === "moving" && train.originalSegment){
              segFrom = train.originalSegment.from;
              segTo = train.originalSegment.to;
            } else {
              if(train.direction === 1){
                segFrom = line.stations[train.currentSegment];
                segTo = line.stations[train.currentSegment+1];
              } else {
                segFrom = line.stations[train.currentSegment+1];
                segTo = line.stations[train.currentSegment];
              }
            }
            let dx = segTo.x - segFrom.x, dy = segTo.y - segFrom.y;
            let ease = train.progress;
            let x = segFrom.x + dx * ease;
            let y = segFrom.y + dy * ease;
            let baseOffset = getSegmentOffset(line, train.currentSegment);
            let offset = 6;
            let group = line.trains.filter(t => t.currentSegment === train.currentSegment);
            group.sort((a,b) => a.id - b.id);
            let idx = group.findIndex(t => t.id === train.id);
            let groupOffset = (group.length % 2 === 1)
              ? (idx - Math.floor(group.length/2)) * offset
              : (idx - group.length/2 + 0.5) * offset;
            let totalOffset = baseOffset + groupOffset;
            let len = Math.sqrt(dx*dx + dy*dy);
            let offX = -dy/len * totalOffset;
            let offY = dx/len * totalOffset;
            x += offX;
            y += offY;
            let angle = Math.atan2(dy, dx);
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.fillStyle = darkenColor(line.color, 0.8);
            ctx.fillRect(-trainWidth/2, -trainHeight/2, trainWidth, trainHeight);
            ctx.strokeStyle = "black";
            ctx.strokeRect(-trainWidth/2, -trainHeight/2, trainWidth, trainHeight);
            if(train.onboard && train.onboard.length > 0){
              let n = train.onboard.length;
              let spacing = trainWidth / (n + 1);
              for(let i = 0; i < n; i++){
                let paxOffsetX = -trainWidth/2 + spacing*(i+1);
                let paxOffsetY = 0;
                ctx.beginPath();
                ctx.arc(paxOffsetX, paxOffsetY, 3, 0, 2*Math.PI);
                ctx.fillStyle = "blue";
                ctx.fill();
                ctx.fillStyle = "white";
                ctx.font = "8px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(train.onboard[i].destinationStation.id, paxOffsetX, paxOffsetY);
              }
            }
            ctx.restore();
            // Draw faded "ghost" segment if the original segment is stored (i.e. if the underlying line changed)
            if(train.state === "moving" && train.originalSegment){
              ctx.save();
              ctx.globalAlpha = 0.3;
              ctx.strokeStyle = line.color;
              ctx.lineWidth = 4;
              ctx.beginPath();
              ctx.moveTo(train.originalSegment.from.x, train.originalSegment.from.y);
              ctx.lineTo(train.originalSegment.to.x, train.originalSegment.to.y);
              ctx.stroke();
              ctx.restore();
            }
            let invX = currentMousePos.x - x, invY = currentMousePos.y - y;
            let cos = Math.cos(-angle), sin = Math.sin(-angle);
            let localX = invX * cos - invY * sin;
            let localY = invX * sin + invY * cos;
            if(localX >= -trainWidth/2 && localX <= trainWidth/2 && localY >= -trainHeight/2 && localY <= trainHeight/2){
              hoveredTrain = train;
            }
          }
        }
      }
      function drawCommuters(){
        let waitingByStation = {};
        for(let commuter of commuters){
          if(commuter.state === "waiting"){
            let id = commuter.currentStation.id;
            if(!waitingByStation[id]) waitingByStation[id] = [];
            waitingByStation[id].push(commuter);
          }
        }
        for(let stationId in waitingByStation){
          let group = waitingByStation[stationId];
          group.sort((a, b) => a.id - b.id);
          let station = stations.find(s => s.id === stationId);
          let baseX = station.x + stationRadius + 5;
          let baseY = station.y - stationRadius - 5;
          let gap = 12;
          for(let i = 0; i < group.length; i++){
            let x = baseX;
            let y = baseY - i * gap;
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, 2*Math.PI);
            ctx.fillStyle = "blue";
            ctx.fill();
            ctx.fillStyle = "red";
            ctx.font = "bold 12px Arial";
            ctx.textAlign = "left";
            ctx.textBaseline = "middle";
            ctx.fillText("→ " + group[i].destinationStation.id, x + 8, y);
          }
        }
      }
      function drawHoveredRoute(){
        if(hoveredCommuter && hoveredCommuter.route){
          ctx.save();
          ctx.strokeStyle = "orange";
          ctx.lineWidth = 3;
          ctx.setLineDash([5,5]);
          for(let seg of hoveredCommuter.route){
            ctx.beginPath();
            ctx.moveTo(seg.from.x, seg.from.y);
            ctx.lineTo(seg.to.x, seg.to.y);
            ctx.stroke();
          }
          ctx.restore();
        }
      }
      function drawArrivalEffects(now){
        for(let i = arrivalEffects.length - 1; i >= 0; i--){
          let effect = arrivalEffects[i];
          let dt = now - effect.startTime;
          let duration = 1000;
          if(dt > duration){
            arrivalEffects.splice(i, 1);
          } else {
            let progress = dt / duration;
            let alpha = 1 - progress;
            let radius = 20 + 20 * progress;
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, radius, 0, 2*Math.PI);
            ctx.strokeStyle = "gold";
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.restore();
          }
        }
      }
      function updateTrainPopup(){
        if(hoveredTrain){
          let list = (hoveredTrain.onboard && hoveredTrain.onboard.length > 0)
                    ? hoveredTrain.onboard.map(p => p.destinationStation.id).join(", ")
                    : "No passengers";
          trainPopup.textContent = "Passengers: " + list;
          trainPopup.style.left = (currentMousePos.x + 15) + "px";
          trainPopup.style.top = (currentMousePos.y + 15) + "px";
          trainPopup.style.display = "block";
        } else {
          trainPopup.style.display = "none";
        }
      }
      function drawBackground(){
        ctx.drawImage(bgCanvas, 0, 0);
      }
      function draw(){
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBackground();
        drawMetroLines();
        drawEndpointTabs();
        drawActiveLine();
        drawStations();
        drawTrains();
        drawCommuters();
        drawHoveredRoute();
        drawArrivalEffects(performance.now());
      }
      function update(now){
        updateTrains(now);
        updateCommuters(now);
        updateTrainPopup();
        draw();
        requestAnimationFrame(update);
      }
      // ========= COMMUTER SIMULATION =========
      function buildGraph(){
        let graph = {};
        for(let s of stations) graph[s.id] = [];
        for(let line of metroLines){
          for(let i = 0; i < line.stations.length - 1; i++){
            let a = line.stations[i], b = line.stations[i+1];
            graph[a.id].push({ station: b, line: line });
            graph[b.id].push({ station: a, line: line });
          }
        }
        return graph;
      }
      function computeRoute(start, goal){
        let graph = buildGraph();
        let queue = [ start ];
        let visited = {};
        visited[start.id] = null;
        while(queue.length){
          let current = queue.shift();
          if(current === goal) break;
          for(let edge of graph[current.id]){
            if(!(edge.station.id in visited)){
              visited[edge.station.id] = { from: current, line: edge.line };
              queue.push(edge.station);
            }
          }
        }
        if(!(goal.id in visited)) return null;
        let route = [];
        let cur = goal;
        while(cur !== start){
          let info = visited[cur.id];
          route.unshift({ from: info.from, to: cur, line: info.line });
          cur = info.from;
        }
        return route;
      }
      function spawnCommuter(){
        if(stations.length < 2) return;
        let start = stations[Math.floor(Math.random()*stations.length)];
        let dest;
        do { dest = stations[Math.floor(Math.random()*stations.length)]; } while(dest === start);
        let route = computeRoute(start, dest);
        let commuter = {
          id: nextCommuterId++,
          currentStation: start,
          destinationStation: dest,
          state: "waiting",
          route: route
        };
        commuters.push(commuter);
      }
      function updateCommuters(now){
        for(let commuter of commuters){
          if(commuter.state === "waiting"){
            if(commuter.currentStation.id === commuter.destinationStation.id){
              commuter.arrived = true;
              arrivedCount++;
              arrivalEffects.push({ x: commuter.currentStation.x, y: commuter.currentStation.y, startTime: now });
              continue;
            }
            commuter.route = computeRoute(commuter.currentStation, commuter.destinationStation);
            if(commuter.route && commuter.route.length > 0){
              let seg = commuter.route[0];
              let candidate = seg.line.trains.find(train => {
                if(train.state !== "dwell") return false;
                let posStation = (train.direction === 1) ? train.line.stations[train.currentSegment] : train.line.stations[train.currentSegment+1];
                if(posStation.id !== commuter.currentStation.id) return false;
                if(train.direction === 1){
                  return train.line.stations[train.currentSegment+1].id === seg.to.id;
                } else {
                  return train.line.stations[train.currentSegment].id === seg.to.id;
                }
              });
              if(candidate){
                commuter.state = "inTrain";
                candidate.onboard = candidate.onboard || [];
                candidate.onboard.push(commuter);
              }
            }
          }
        }
        commuters = commuters.filter(c => !c.arrived && c.currentStation.id !== c.destinationStation.id);
        counterDiv.textContent = "Arrived: " + arrivedCount;
      }
      // ========= INITIALIZATION =========
      initStations();
      setInterval(spawnCommuter, commuterSpawnInterval);
      requestAnimationFrame(update);
    })();
  </script>
</body>
</html>
