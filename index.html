<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Metro System Designer & Simulator</title>
  <style>
    body { font-family: sans-serif; }
    canvas { border: 1px solid #000; background-color: #f0f0f0; }
    #controls { margin-bottom: 10px; }
    #controls > * { margin-right: 10px; }
  </style>
</head>
<body>
  <h1>Metro System Designer & Simulator</h1>
  <div id="controls">
    <label for="lineColorDropdown">Line Color:</label>
    <select id="lineColorDropdown">
      <option value="#ff0000" selected>Red</option>
      <option value="#0000ff">Blue</option>
      <option value="#00ff00">Green</option>
      <option value="#ffff00">Yellow</option>
      <option value="#800080">Purple</option>
      <option value="#ffa500">Orange</option>
      <option value="#00ffff">Cyan</option>
      <option value="#ff00ff">Magenta</option>
      <option value="#8b4513">Brown</option>
      <option value="#000000">Black</option>
    </select>
    <button id="newLineButton">New Line</button>
    <button id="deleteLineButton">Delete Line</button>
  </div>
  <p>
    <strong>How to use:</strong><br>
    • Click “New Line” then click on a station to begin drawing a new metro line. As you drag, if you pass near another station the route “snaps” to it.  
    • If you drag over a station already in the route (other than the last), the route is trimmed (removing stops after that station).  
    • Dragging to the starting station (with at least 2 stops) completes the loop.  
    • To modify an existing line, click on a segment. Then drag from that clicked “pivot” point to a new station. A faint copy of the original route is shown; releasing over a station (different from the pivot’s neighbors) will insert that stop into the route – otherwise the route reverts.  
    • “Delete Line” removes every line whose color matches the current dropdown selection.  
    • Waiting commuters are drawn as small blue circles with a bold red “→ X” label showing their target. Hovering over one will highlight their planned route.  
    • Passengers board trains and are drawn inside the train (they remain visible during part of the dwell period).
  </p>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <script>
    (function(){
      // ========= CONFIGURATION =========
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const stationRadius = 15;
      const snapThreshold = 20; // for snapping when drawing
      const trainWidth = 30, trainHeight = 15;
      const dwellTime = 2000;      // ms dwell time at a station
      const acceleration = 0.001;  // px/(ms^2)
      const maxSpeed = 0.3;        // px/ms
      const commuterSpawnInterval = 3000; // ms between spawns
      const stationCount = 10; // total stations

      // ========= DATA STRUCTURES =========
      let stations = [];      // each station: { id, x, y }
      let metroLines = [];    // each line: { id, color, stations: [...], trains: [], isLoop }
      // activeLine is used when drawing a new line or modifying an existing one.
      // For modification mode, we store: editingMode = "modify", modifySegmentIndex, originalStations, modifyCursor, modifyCandidate.
      let activeLine = null;

      // Commuters: { id, currentStation, destinationStation, state:"waiting"|"inTrain", route:[{line, from, to}] }
      let commuters = [];
      // Unique id counters:
      let nextLineId = 1, nextTrainId = 1, nextCommuterId = 1;

      // For mouseover route highlighting.
      let hoveredCommuter = null;

      // ========= UI ELEMENTS =========
      const lineColorDropdown = document.getElementById('lineColorDropdown');
      const newLineButton = document.getElementById('newLineButton');
      const deleteLineButton = document.getElementById('deleteLineButton');

      newLineButton.addEventListener('click', () => {
        if(activeLine) return;
        activeLine = {
          id: nextLineId++,
          color: lineColorDropdown.value,
          stations: [],
          trains: [],
          editingMode: "new"
        };
      });

      // Delete all lines matching the selected color.
      deleteLineButton.addEventListener('click', () => {
        metroLines = metroLines.filter(line => line.color !== lineColorDropdown.value);
      });

      // ========= INITIALIZE STATIONS =========
      function initStations(){
        const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        for(let i = 0; i < stationCount; i++){
          let s = {
            id: letters[i],
            x: Math.random()*(canvas.width-40) + 20,
            y: Math.random()*(canvas.height-40) + 20
          };
          stations.push(s);
        }
      }

      // ========= HELPER FUNCTIONS =========
      function distance(x1, y1, x2, y2){
        return Math.hypot(x2-x1, y2-y1);
      }

      // Return station if (x,y) is within stationRadius.
      function getStationAt(x, y){
        for(let s of stations){
          if(distance(x, y, s.x, s.y) < stationRadius) return s;
        }
        return null;
      }

      // If (x,y) is within snapThreshold of a station, return that station.
      function getSnappedStation(x, y){
        for(let s of stations){
          if(distance(x, y, s.x, s.y) < snapThreshold) return s;
        }
        return null;
      }

      // Check if (x,y) is near any segment of any metro line.
      // Returns { line, segmentIndex } if found.
      function getLineSegmentAt(x, y){
        for(let line of metroLines){
          for(let i = 0; i < line.stations.length - 1; i++){
            let a = line.stations[i], b = line.stations[i+1];
            let d = distanceToSegment(x, y, a.x, a.y, b.x, b.y);
            if(d < 5) return { line: line, segmentIndex: i };
          }
        }
        return null;
      }

      // Distance from point (px,py) to segment from (x1,y1) to (x2,y2)
      function distanceToSegment(px, py, x1, y1, x2, y2){
        const l2 = Math.pow(distance(x1, y1, x2, y2), 2);
        if(l2 === 0) return distance(px, py, x1, y1);
        let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2;
        t = Math.max(0, Math.min(1, t));
        return distance(px, py, x1 + t*(x2-x1), y1 + t*(y2-y1));
      }

      // Compute travel time along a segment of length d using acceleration/deceleration.
      function computeTravelTime(d){
        const t_acc = maxSpeed / acceleration;
        const d_acc = 0.5 * acceleration * t_acc * t_acc;
        if(d >= 2 * d_acc){
          let t_cruise = (d - 2 * d_acc) / maxSpeed;
          return t_acc + t_cruise + t_acc;
        } else {
          return 2 * Math.sqrt(d / acceleration);
        }
      }

      // ========= LINE DRAWING / EDITING =========
      let isDragging = false;
      let currentMousePos = { x: 0, y: 0 };

      canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        let x = e.clientX - rect.left;
        let y = e.clientY - rect.top;
        if(!activeLine){
          // Try to select an existing line for modification.
          let segInfo = getLineSegmentAt(x, y);
          if(segInfo){
            activeLine = segInfo.line;
            activeLine.editingMode = "modify";
            activeLine.modifySegmentIndex = segInfo.segmentIndex;
            activeLine.originalStations = activeLine.stations.slice();
            activeLine.modifyCursor = { x, y };
            activeLine.modifyCandidate = null;
          }
        } else if(activeLine.editingMode === "new"){
          // For a new line, if no station has been added yet, snap to a station.
          if(activeLine.stations.length === 0){
            let s = getStationAt(x, y);
            if(s) activeLine.stations.push(s);
          }
        }
        isDragging = true;
      });

      canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        currentMousePos.x = e.clientX - rect.left;
        currentMousePos.y = e.clientY - rect.top;

        // --- Active line drawing or modification ---
        if(activeLine && isDragging){
          if(activeLine.editingMode === "new"){
            // For new line drawing, try snapping to a station.
            let snapped = getSnappedStation(currentMousePos.x, currentMousePos.y);
            if(snapped){
              let arr = activeLine.stations;
              let idx = arr.indexOf(snapped);
              if(idx !== -1 && idx < arr.length - 1){
                // If already in route (but not as the last), trim route.
                activeLine.stations = arr.slice(0, idx+1);
              } else if(arr.length === 0){
                activeLine.stations.push(snapped);
              } else if(arr[arr.length-1] !== snapped){
                activeLine.stations.push(snapped);
              }
            }
          } else if(activeLine.editingMode === "modify"){
            // For modifying an existing line, update the modification cursor.
            let candidate = getSnappedStation(currentMousePos.x, currentMousePos.y);
            if(candidate){
              activeLine.modifyCursor = { x: candidate.x, y: candidate.y };
              activeLine.modifyCandidate = candidate;
            } else {
              activeLine.modifyCursor = { x: currentMousePos.x, y: currentMousePos.y };
              activeLine.modifyCandidate = null;
            }
          }
        }

        // --- Hover detection for waiting commuters ---
        // Group waiting commuters by station and compute their drawn positions.
        hoveredCommuter = null;
        let waitingByStation = {};
        for(let commuter of commuters){
          if(commuter.state === "waiting"){
            let id = commuter.currentStation.id;
            if(!waitingByStation[id]) waitingByStation[id] = [];
            waitingByStation[id].push(commuter);
          }
        }
        for(let stationId in waitingByStation){
          let group = waitingByStation[stationId];
          // Sort group for consistent ordering.
          group.sort((a,b) => a.id - b.id);
          // Compute offsets so they appear side by side.
          let station = stations.find(s => s.id === stationId);
          let spacing = 12;
          for(let i = 0; i < group.length; i++){
            let offset = (i - (group.length - 1)/2) * spacing;
            let pos = { x: station.x + offset, y: station.y };
            if(distance(currentMousePos.x, currentMousePos.y, pos.x, pos.y) < 8){
              hoveredCommuter = group[i];
              break;
            }
          }
          if(hoveredCommuter) break;
        }
      });

      canvas.addEventListener('mouseup', (e) => {
        isDragging = false;
        if(activeLine){
          if(activeLine.editingMode === "modify"){
            let idx = activeLine.modifySegmentIndex;
            let X = activeLine.originalStations[idx];
            let Y = activeLine.originalStations[idx+1];
            // If a candidate station was snapped and it isn’t equal to X or Y, insert it.
            if(activeLine.modifyCandidate && activeLine.modifyCandidate !== X && activeLine.modifyCandidate !== Y){
              activeLine.stations = activeLine.originalStations.slice();
              activeLine.stations.splice(idx+1, 0, activeLine.modifyCandidate);
            } else {
              // Revert modification.
              activeLine.stations = activeLine.originalStations.slice();
            }
            activeLine.editingMode = "new"; // modification complete
            activeLine = null;
          }
        }
      });

      // On double-click, finish drawing a new line.
      canvas.addEventListener('dblclick', (e) => {
        if(activeLine && activeLine.editingMode === "new"){
          if(activeLine.stations.length >= 2){
            // If first and last station are the same (with at least 3 stops), it's a loop.
            if(activeLine.stations[0] === activeLine.stations[activeLine.stations.length-1] &&
               activeLine.stations.length >= 3){
              activeLine.isLoop = true;
            } else {
              activeLine.isLoop = false;
            }
            metroLines.push(activeLine);
            spawnDefaultTrains(activeLine);
          }
          activeLine = null;
        }
      });

      // ========= TRAIN SIMULATION =========
      // Each train: { id, line, direction (1 or -1), currentSegment, progress (0..1),
      // state: "dwell" or "moving", dwellStart, departureTime, travelTime, onboard: [] }
      function spawnDefaultTrains(line){
        line.trains = [];
        let now = performance.now();
        if(!line.isLoop){
          // For non-loop lines, spawn one train at each end.
          line.trains.push({
            id: nextTrainId++,
            line: line,
            direction: 1,
            currentSegment: 0, // from first to second station
            progress: 0,
            state: "dwell",
            dwellStart: now,
            travelTime: 0,
            onboard: []
          });
          line.trains.push({
            id: nextTrainId++,
            line: line,
            direction: -1,
            currentSegment: line.stations.length - 2, // from last to second-last
            progress: 0,
            state: "dwell",
            dwellStart: now,
            travelTime: 0,
            onboard: []
          });
        } else {
          // For loop lines, spawn two trains going in opposite directions.
          let idx1 = 0;
          let idx2 = Math.floor((line.stations.length - 1) / 2);
          line.trains.push({
            id: nextTrainId++,
            line: line,
            direction: 1,
            currentSegment: idx1,
            progress: 0,
            state: "dwell",
            dwellStart: now,
            travelTime: 0,
            onboard: []
          });
          line.trains.push({
            id: nextTrainId++,
            line: line,
            direction: -1,
            currentSegment: idx2,
            progress: 0,
            state: "dwell",
            dwellStart: now,
            travelTime: 0,
            onboard: []
          });
        }
      }

      function updateTrains(now){
        for(let line of metroLines){
          for(let train of line.trains){
            // Determine endpoints based on direction.
            let from, to;
            if(train.direction === 1){
              from = line.stations[train.currentSegment];
              to = line.stations[train.currentSegment+1];
            } else {
              from = line.stations[train.currentSegment+1];
              to = line.stations[train.currentSegment];
            }
            let segLength = distance(from.x, from.y, to.x, to.y);
            if(train.state === "dwell"){
              if(now - train.dwellStart >= dwellTime){
                train.travelTime = computeTravelTime(segLength);
                train.state = "moving";
                train.departureTime = now;
              }
            } else if(train.state === "moving"){
              let elapsed = now - train.departureTime;
              let p = elapsed / train.travelTime;
              let ease = 0.5 - 0.5 * Math.cos(Math.PI * Math.min(p, 1));
              train.progress = ease;
              if(p >= 1){
                // Arrived at next station.
                if(line.isLoop){
                  train.currentSegment = (train.currentSegment + train.direction) % (line.stations.length - 1);
                  if(train.currentSegment < 0) train.currentSegment += (line.stations.length - 1);
                } else {
                  if(train.direction === 1 && train.currentSegment >= line.stations.length - 2){
                    train.direction = -1;
                  } else if(train.direction === -1 && train.currentSegment <= 0){
                    train.direction = 1;
                  }
                  train.currentSegment += train.direction;
                }
                train.state = "dwell";
                train.dwellStart = now;
                train.progress = 0;
              }
            }
          }
        }
      }

      // ========= COMMUTER SIMULATION =========
      // Build a graph from all metro line segments.
      function buildGraph(){
        let graph = {};
        for(let s of stations) graph[s.id] = [];
        for(let line of metroLines){
          for(let i = 0; i < line.stations.length - 1; i++){
            let a = line.stations[i], b = line.stations[i+1];
            graph[a.id].push({ station: b, line: line });
            graph[b.id].push({ station: a, line: line });
          }
        }
        return graph;
      }

      // BFS to compute a route from start to goal.
      // Returns an array of segments: { from, to, line }
      function computeRoute(start, goal){
        let graph = buildGraph();
        let queue = [ start ];
        let visited = {};
        visited[start.id] = null;
        while(queue.length){
          let current = queue.shift();
          if(current === goal) break;
          for(let edge of graph[current.id]){
            if(!(edge.station.id in visited)){
              visited[edge.station.id] = { from: current, line: edge.line };
              queue.push(edge.station);
            }
          }
        }
        if(!(goal.id in visited)) return null;
        let route = [];
        let cur = goal;
        while(cur !== start){
          let info = visited[cur.id];
          route.unshift({ from: info.from, to: cur, line: info.line });
          cur = info.from;
        }
        return route;
      }

      // Spawn a commuter at a random station with a random destination.
      function spawnCommuter(){
        if(stations.length < 2) return;
        let start = stations[Math.floor(Math.random()*stations.length)];
        let dest;
        do {
          dest = stations[Math.floor(Math.random()*stations.length)];
        } while(dest === start);
        let route = computeRoute(start, dest);
        let commuter = {
          id: nextCommuterId++,
          currentStation: start,
          destinationStation: dest,
          state: "waiting",  // "waiting" or "inTrain"
          route: route
        };
        commuters.push(commuter);
      }

      function updateCommuters(now){
        // Board waiting commuters.
        for(let commuter of commuters){
          if(commuter.state === "waiting"){
            if(commuter.currentStation === commuter.destinationStation) continue;
            if(!commuter.route) commuter.route = computeRoute(commuter.currentStation, commuter.destinationStation);
            if(commuter.route && commuter.route.length > 0){
              let seg = commuter.route[0];
              // Look for a train on seg.line dwelling at commuter.currentStation.
              let candidate = seg.line.trains.find(train => {
                if(train.state !== "dwell") return false;
                let posStation = (train.direction === 1) ? seg.line.stations[train.currentSegment] : seg.line.stations[train.currentSegment+1];
                return posStation === commuter.currentStation;
              });
              if(candidate){
                commuter.state = "inTrain";
                candidate.onboard = candidate.onboard || [];
                candidate.onboard.push(commuter);
              }
            }
          }
        }
        // Disembark passengers after a portion of the dwell period.
        for(let line of metroLines){
          for(let train of line.trains){
            if(train.state === "dwell" && (now - train.dwellStart >= dwellTime * 0.8) && train.onboard.length > 0){
              let currentStation = (train.direction === 1) ? line.stations[train.currentSegment] : line.stations[train.currentSegment+1];
              train.onboard.forEach(commuter => {
                if(commuter.route && commuter.route.length > 0 && commuter.route[0].to === currentStation){
                  commuter.currentStation = currentStation;
                  commuter.state = "waiting";
                  commuter.route.shift();
                }
              });
              // Keep the onboard list until next update so passengers remain visible briefly.
              // Then clear it.
              train.onboard = [];
            }
          }
        }
        commuters = commuters.filter(c => c.currentStation !== c.destinationStation);
      }

      // ========= DRAWING FUNCTIONS =========

      // For metro lines that share the same segment between two stations,
      // compute an offset (in pixels) based on how many lines share that segment.
      function getSegmentOffset(line, segmentIndex){
        let a = line.stations[segmentIndex], b = line.stations[segmentIndex+1];
        let sameSegmentLines = metroLines.filter(l => {
          for(let i = 0; i < l.stations.length - 1; i++){
            let p = l.stations[i], q = l.stations[i+1];
            if((p === a && q === b) || (p === b && q === a)) return true;
          }
          return false;
        });
        sameSegmentLines.sort((l1, l2) => l1.id - l2.id);
        let idx = sameSegmentLines.findIndex(l => l.id === line.id);
        let count = sameSegmentLines.length;
        let offsetDistance = 10;  // increased for clarity
        let offset = 0;
        if(count % 2 === 1){
          let mid = Math.floor(count/2);
          offset = (idx - mid) * offsetDistance;
        } else {
          let mid = count/2;
          offset = (idx - mid + 0.5) * offsetDistance;
        }
        return offset;
      }

      function drawStations(){
        for(let s of stations){
          ctx.beginPath();
          ctx.arc(s.x, s.y, stationRadius, 0, 2 * Math.PI);
          ctx.fillStyle = "#FFF";
          ctx.fill();
          ctx.strokeStyle = "#000";
          ctx.stroke();
          ctx.fillStyle = "#000";
          ctx.font = "12px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(s.id, s.x, s.y);
        }
      }

      function drawMetroLines(){
        for(let line of metroLines){
          ctx.beginPath();
          ctx.lineWidth = 4;
          ctx.strokeStyle = line.color;
          for(let i = 0; i < line.stations.length - 1; i++){
            let s1 = line.stations[i];
            let s2 = line.stations[i+1];
            let offset = getSegmentOffset(line, i);
            let dx = s2.x - s1.x, dy = s2.y - s1.y;
            let len = Math.sqrt(dx*dx + dy*dy);
            let offX = -dy/len * offset;
            let offY = dx/len * offset;
            let startX = s1.x + offX;
            let startY = s1.y + offY;
            let endX = s2.x + offX;
            let endY = s2.y + offY;
            if(i === 0) ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
          }
          ctx.stroke();
          ctx.lineWidth = 2;
        }
      }

      // Draw active line (either new or in modification mode)
      function drawActiveLine(){
        if(activeLine){
          if(activeLine.editingMode === "new"){
            ctx.beginPath();
            ctx.lineWidth = 4;
            ctx.strokeStyle = activeLine.color;
            for(let i = 0; i < activeLine.stations.length; i++){
              let s = activeLine.stations[i];
              if(i === 0) ctx.moveTo(s.x, s.y);
              else ctx.lineTo(s.x, s.y);
            }
            if(activeLine.stations.length > 0){
              ctx.lineTo(currentMousePos.x, currentMousePos.y);
            }
            ctx.stroke();
            ctx.lineWidth = 2;
          } else if(activeLine.editingMode === "modify"){
            // Draw the original line faintly.
            ctx.save();
            ctx.globalAlpha = 0.3;
            ctx.beginPath();
            ctx.strokeStyle = activeLine.color;
            for(let i = 0; i < activeLine.originalStations.length; i++){
              let s = activeLine.originalStations[i];
              if(i === 0) ctx.moveTo(s.x, s.y);
              else ctx.lineTo(s.x, s.y);
            }
            ctx.stroke();
            ctx.restore();
            // Draw the modified version.
            let tempStations = activeLine.originalStations.slice();
            let idx = activeLine.modifySegmentIndex;
            tempStations.splice(idx+1, 0, activeLine.modifyCursor);
            ctx.beginPath();
            ctx.lineWidth = 4;
            ctx.strokeStyle = activeLine.color;
            for(let i = 0; i < tempStations.length; i++){
              let p = tempStations[i];
              if(i === 0) ctx.moveTo(p.x, p.y);
              else ctx.lineTo(p.x, p.y);
            }
            ctx.stroke();
            ctx.lineWidth = 2;
          }
        }
      }

      // Draw trains. Trains on the same segment of the same line are grouped and offset.
      function drawTrains(){
        // Group trains by key: line.id + "_" + train.currentSegment.
        let trainsBySegment = {};
        for(let line of metroLines){
          for(let train of line.trains){
            let key = line.id + "_" + train.currentSegment;
            if(!trainsBySegment[key]) trainsBySegment[key] = [];
            trainsBySegment[key].push(train);
          }
        }
        for(let key in trainsBySegment){
          let group = trainsBySegment[key];
          group.sort((a, b) => a.id - b.id);
          let count = group.length;
          group.forEach((train, idx) => {
            let offsetDistance = 6;
            let offset = 0;
            if(count % 2 === 1){
              let mid = Math.floor(count/2);
              offset = (idx - mid) * offsetDistance;
            } else {
              let mid = count/2;
              offset = (idx - mid + 0.5) * offsetDistance;
            }
            // Compute train position along its segment.
            let from, to;
            if(train.direction === 1){
              from = train.line.stations[train.currentSegment];
              to = train.line.stations[train.currentSegment+1];
            } else {
              from = train.line.stations[train.currentSegment+1];
              to = train.line.stations[train.currentSegment];
            }
            let x = from.x + (to.x - from.x) * train.progress;
            let y = from.y + (to.y - from.y) * train.progress;
            // Apply the same offset as the line.
            let dx = to.x - from.x, dy = to.y - from.y;
            let len = Math.sqrt(dx*dx + dy*dy);
            let offX = -dy/len * getSegmentOffset(train.line, train.currentSegment);
            let offY = dx/len * getSegmentOffset(train.line, train.currentSegment);
            // Then add additional offset for multiple trains on same segment.
            let addOffX = -dy/len * offset;
            let addOffY = dx/len * offset;
            x += offX + addOffX;
            y += offY + addOffY;
            let angle = Math.atan2(to.y - from.y, to.x - from.x);
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.fillStyle = "green";
            ctx.fillRect(-trainWidth/2, -trainHeight/2, trainWidth, trainHeight);
            ctx.strokeStyle = "black";
            ctx.strokeRect(-trainWidth/2, -trainHeight/2, trainWidth, trainHeight);
            // Optionally draw train id.
            ctx.fillStyle = "white";
            ctx.font = "10px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(train.id, 0, 0);
            // Draw onboard passengers inside the train.
            if(train.onboard && train.onboard.length > 0){
              let n = train.onboard.length;
              for(let i = 0; i < n; i++){
                let paxOffsetX = -trainWidth/2 + (trainWidth/(n+1))*(i+1);
                let paxOffsetY = 0;
                ctx.beginPath();
                ctx.arc(paxOffsetX, paxOffsetY, 3, 0, 2*Math.PI);
                ctx.fillStyle = "blue";
                ctx.fill();
                ctx.fillStyle = "white";
                ctx.font = "8px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(train.onboard[i].destinationStation.id, paxOffsetX, paxOffsetY);
              }
            }
            ctx.restore();
          });
        }
      }

      // Draw waiting commuters grouped by station.
      function drawCommuters(){
        let waitingByStation = {};
        for(let commuter of commuters){
          if(commuter.state === "waiting"){
            let id = commuter.currentStation.id;
            if(!waitingByStation[id]) waitingByStation[id] = [];
            waitingByStation[id].push(commuter);
          }
        }
        for(let stationId in waitingByStation){
          let group = waitingByStation[stationId];
          group.sort((a, b) => a.id - b.id);
          let spacing = 12;
          let station = stations.find(s => s.id === stationId);
          for(let i = 0; i < group.length; i++){
            let offset = (i - (group.length - 1)/2) * spacing;
            let x = station.x + offset;
            let y = station.y;
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, 2*Math.PI);
            ctx.fillStyle = "blue";
            ctx.fill();
            ctx.fillStyle = "red";
            ctx.font = "bold 12px Arial";
            ctx.textAlign = "left";
            ctx.textBaseline = "middle";
            ctx.fillText("→ " + group[i].destinationStation.id, x + 8, y - 10);
          }
        }
      }

      // If a commuter is hovered, draw their planned route.
      function drawHoveredRoute(){
        if(hoveredCommuter && hoveredCommuter.route){
          ctx.save();
          ctx.strokeStyle = "orange";
          ctx.lineWidth = 3;
          ctx.setLineDash([5,5]);
          let route = hoveredCommuter.route;
          for(let seg of route){
            ctx.beginPath();
            ctx.moveTo(seg.from.x, seg.from.y);
            ctx.lineTo(seg.to.x, seg.to.y);
            ctx.stroke();
          }
          ctx.restore();
        }
      }

      function draw(){
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawMetroLines();
        drawActiveLine();
        drawStations();
        drawTrains();
        drawCommuters();
        drawHoveredRoute();
      }

      // ========= UPDATE LOOP =========
      function update(now){
        updateTrains(now);
        updateCommuters(now);
        draw();
        requestAnimationFrame(update);
      }

      // ========= INITIALIZATION =========
      initStations();
      setInterval(spawnCommuter, commuterSpawnInterval);
      requestAnimationFrame(update);
    })();
  </script>
</body>
</html>
