<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Metro System Designer & Simulator</title>
  <style>
    body { font-family: sans-serif; margin:0; padding:0; }
    canvas { border: 1px solid #000; background-color: #f0f0f0; display: block; margin: 0 auto; }
    #controls { margin: 10px; }
    #controls > * { margin-right: 10px; }
    #counter { position: absolute; top: 10px; right: 10px; font-size: 18px; font-weight: bold; background: rgba(255,255,255,0.8); padding: 5px 10px; border: 1px solid #000; }
  </style>
</head>
<body>
  <div id="controls">
    <label for="lineColorDropdown">Line Color:</label>
    <select id="lineColorDropdown">
      <option value="#ff0000" selected>Red</option>
      <option value="#0000ff">Blue</option>
      <option value="#00ff00">Green</option>
      <option value="#ffff00">Yellow</option>
      <option value="#800080">Purple</option>
      <option value="#ffa500">Orange</option>
      <option value="#00ffff">Cyan</option>
      <option value="#ff00ff">Magenta</option>
      <option value="#8b4513">Brown</option>
      <option value="#000000">Black</option>
    </select>
    <button id="newLineButton">New Line</button>
    <button id="deleteLineButton">Delete Line</button>
  </div>
  <div id="counter">Arrived: 0</div>
  <p style="margin:10px;">
    <strong>How to use:</strong><br>
    • Click “New Line” then click on a station to begin drawing a new metro line. As you drag, if you pass near another station the route “snaps” to it. (If the station is already in the route, it won’t be added again – except you can undo the last station by dragging back over the station immediately before the last.)<br>
    • In modify mode (by clicking an existing segment) drag from the pivot point. Dragging over one of the two endpoints of that segment (by comparing IDs) will remove that stop (non‑loops only); dragging over any other station inserts it between.<br>
    • “Delete Line” removes every line whose color matches the current dropdown selection.<br>
    • Waiting commuters are drawn as small blue circles with a bold red “→ X” label showing their target. Hovering over one highlights its planned route.<br>
    • Passengers board trains and are drawn inside the train. When they reach their destination the commuter disembarks with a “tada” burst at the station and the global counter increases.<br>
    • Stations are placed so that they don’t get too close together.
  </p>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <script>
    (function(){
      // ========= CONFIGURATION =========
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const stationRadius = 15;
      const snapThreshold = 20; // for snapping when drawing
      const trainWidth = 30, trainHeight = 15;
      const dwellTime = 2000;      // ms dwell time at a station
      const acceleration = 0.001;  // px/(ms^2)
      const maxSpeed = 0.3;        // px/ms
      const commuterSpawnInterval = 3000; // ms between spawns
      const stationCount = 10; // total stations
      const minStationDist = 80; // minimum distance between stations

      // ========= GLOBAL STATE =========
      let stations = [];      // each station: { id, x, y }
      let metroLines = [];    // each line: { id, color, stations: [...], trains: [], isLoop }
      // activeLine is used when drawing a new line or modifying an existing one.
      // In modify mode, we store: editingMode = "modify", modifySegmentIndex, originalStations, modifyCursor, modifyCandidate.
      let activeLine = null;
      // Commuters: { id, currentStation, destinationStation, state:"waiting"|"inTrain", route:[{line, from, to}] }
      let commuters = [];
      let nextLineId = 1, nextTrainId = 1, nextCommuterId = 1;
      // For arrival effects and counter.
      let arrivedCount = 0;
      let arrivalEffects = []; // each: { x, y, startTime }

      // For mouseover route highlighting.
      let hoveredCommuter = null;

      // ========= UI ELEMENTS =========
      const lineColorDropdown = document.getElementById('lineColorDropdown');
      const newLineButton = document.getElementById('newLineButton');
      const deleteLineButton = document.getElementById('deleteLineButton');
      const counterDiv = document.getElementById('counter');

      newLineButton.addEventListener('click', () => {
        if(activeLine) return;
        activeLine = {
          id: nextLineId++,
          color: lineColorDropdown.value,
          stations: [],
          trains: [],
          editingMode: "new"
        };
      });

      // Delete all lines matching the selected color.
      deleteLineButton.addEventListener('click', () => {
        metroLines = metroLines.filter(line => line.color !== lineColorDropdown.value);
      });

      // ========= INITIALIZE STATIONS =========
      function initStations(){
        const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        let attempts = 0;
        for(let i = 0; i < stationCount; i++){
          let valid = false;
          let s;
          while(!valid && attempts < 1000){
            s = {
              id: letters[i],
              x: Math.random()*(canvas.width-80) + 40,
              y: Math.random()*(canvas.height-80) + 40
            };
            valid = stations.every(st => distance(st.x, st.y, s.x, s.y) >= minStationDist);
            attempts++;
          }
          stations.push(s);
        }
      }

      // ========= HELPER FUNCTIONS =========
      function distance(x1, y1, x2, y2){
        return Math.hypot(x2-x1, y2-y1);
      }

      // Return station if (x,y) is within stationRadius.
      function getStationAt(x, y){
        for(let s of stations){
          if(distance(x, y, s.x, s.y) < stationRadius) return s;
        }
        return null;
      }

      // If (x,y) is within snapThreshold of a station, return that station.
      function getSnappedStation(x, y){
        for(let s of stations){
          if(distance(x, y, s.x, s.y) < snapThreshold) return s;
        }
        return null;
      }

      // Check if (x,y) is near any segment of any metro line.
      // Returns { line, segmentIndex } if found.
      function getLineSegmentAt(x, y){
        for(let line of metroLines){
          for(let i = 0; i < line.stations.length - 1; i++){
            let a = line.stations[i], b = line.stations[i+1];
            let d = distanceToSegment(x, y, a.x, a.y, b.x, b.y);
            if(d < 5) return { line: line, segmentIndex: i };
          }
        }
        return null;
      }

      // Distance from point (px,py) to segment from (x1,y1) to (x2,y2)
      function distanceToSegment(px, py, x1, y1, x2, y2){
        const l2 = Math.pow(distance(x1, y1, x2, y2), 2);
        if(l2 === 0) return distance(px, py, x1, y1);
        let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2;
        t = Math.max(0, Math.min(1, t));
        return distance(px, py, x1 + t*(x2-x1), y1 + t*(y2-y1));
      }

      // Compute travel time along a segment of length d.
      function computeTravelTime(d){
        const t_acc = maxSpeed / acceleration;
        const d_acc = 0.5 * acceleration * t_acc * t_acc;
        if(d >= 2 * d_acc){
          let t_cruise = (d - 2 * d_acc) / maxSpeed;
          return t_acc + t_cruise + t_acc;
        } else {
          return 2 * Math.sqrt(d / acceleration);
        }
      }

      // ========= LINE DRAWING / EDITING =========
      let isDragging = false;
      let currentMousePos = { x: 0, y: 0 };

      canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        let x = e.clientX - rect.left;
        let y = e.clientY - rect.top;
        if(!activeLine){
          // Try to select an existing line for modification.
          let segInfo = getLineSegmentAt(x, y);
          if(segInfo){
            activeLine = segInfo.line;
            activeLine.editingMode = "modify";
            activeLine.modifySegmentIndex = segInfo.segmentIndex;
            activeLine.originalStations = activeLine.stations.slice();
            activeLine.modifyCursor = { x, y };
            activeLine.modifyCandidate = null;
          }
        } else if(activeLine.editingMode === "new"){
          // For a new line, if no station has been added yet, snap to a station.
          if(activeLine.stations.length === 0){
            let s = getStationAt(x, y);
            if(s) activeLine.stations.push(s);
          }
        }
        isDragging = true;
      });

      canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        currentMousePos.x = e.clientX - rect.left;
        currentMousePos.y = e.clientY - rect.top;

        // --- Active line drawing or modification ---
        if(activeLine && isDragging){
          if(activeLine.editingMode === "new"){
            let snapped = getSnappedStation(currentMousePos.x, currentMousePos.y);
            if(snapped){
              let arr = activeLine.stations;
              // Prevent duplicates: if the station is already in the route, do nothing,
              // except allow removal if it's immediately before the last.
              if(arr.length > 0 && arr[arr.length-1].id === snapped.id){
                // Do nothing.
              } else if(arr.length > 1 && arr[arr.length-2].id === snapped.id){
                arr.pop();
              } else if(arr.some(s => s.id === snapped.id)){
                // Already in route (but not immediately preceding last): do nothing.
              } else {
                arr.push(snapped);
              }
            }
          } else if(activeLine.editingMode === "modify"){
            // Update modify cursor and candidate.
            let candidate = getSnappedStation(currentMousePos.x, currentMousePos.y);
            if(candidate){
              activeLine.modifyCursor = { x: candidate.x, y: candidate.y };
              activeLine.modifyCandidate = candidate;
            } else {
              activeLine.modifyCursor = { x: currentMousePos.x, y: currentMousePos.y };
              activeLine.modifyCandidate = null;
            }
          }
        }

        // --- Hover detection for waiting commuters ---
        hoveredCommuter = null;
        let waitingByStation = {};
        for(let commuter of commuters){
          if(commuter.state === "waiting"){
            let id = commuter.currentStation.id;
            if(!waitingByStation[id]) waitingByStation[id] = [];
            waitingByStation[id].push(commuter);
          }
        }
        for(let stationId in waitingByStation){
          let group = waitingByStation[stationId];
          group.sort((a,b) => a.id - b.id);
          let station = stations.find(s => s.id === stationId);
          let spacing = 12;
          for(let i = 0; i < group.length; i++){
            let offset = (i - (group.length - 1)/2) * spacing;
            let pos = { x: station.x + offset, y: station.y };
            if(distance(currentMousePos.x, currentMousePos.y, pos.x, pos.y) < 8){
              hoveredCommuter = group[i];
              break;
            }
          }
          if(hoveredCommuter) break;
        }
      });

      canvas.addEventListener('mouseup', (e) => {
        isDragging = false;
        if(activeLine){
          if(activeLine.editingMode === "modify"){
            let idx = activeLine.modifySegmentIndex;
            let X = activeLine.originalStations[idx];
            let Y = activeLine.originalStations[idx+1];
            // In non-loop lines only, allow removal if candidate matches one of the endpoints.
            if(!activeLine.isLoop && activeLine.modifyCandidate){
              if(activeLine.modifyCandidate.id === X.id && idx > 0){
                activeLine.stations = activeLine.originalStations.slice();
                activeLine.stations.splice(idx, 1);
              } else if(activeLine.modifyCandidate.id === Y.id && idx+1 < activeLine.originalStations.length - 1){
                activeLine.stations = activeLine.originalStations.slice();
                activeLine.stations.splice(idx+1, 1);
              } else if(activeLine.modifyCandidate.id !== X.id && activeLine.modifyCandidate.id !== Y.id){
                activeLine.stations = activeLine.originalStations.slice();
                activeLine.stations.splice(idx+1, 0, activeLine.modifyCandidate);
              } else {
                activeLine.stations = activeLine.originalStations.slice();
              }
            } else {
              activeLine.stations = activeLine.originalStations.slice();
            }
            activeLine.editingMode = "new";
            activeLine = null;
          }
        }
      });

      // On double-click, finish drawing a new line.
      canvas.addEventListener('dblclick', (e) => {
        if(activeLine && activeLine.editingMode === "new"){
          if(activeLine.stations.length >= 2){
            // Do not allow loops – each station must appear only once.
            activeLine.isLoop = false;
            metroLines.push(activeLine);
            spawnDefaultTrains(activeLine);
          }
          activeLine = null;
        }
      });

      // ========= TRAIN SIMULATION =========
      // Each train: { id, line, direction (1 or -1), currentSegment, progress, state:"dwell"|"moving",
      // dwellStart, departureTime, travelTime, onboard: [] }
      function spawnDefaultTrains(line){
        line.trains = [];
        let now = performance.now();
        if(!line.isLoop){
          line.trains.push({
            id: nextTrainId++,
            line: line,
            direction: 1,
            currentSegment: 0,
            progress: 0,
            state: "dwell",
            dwellStart: now,
            travelTime: 0,
            onboard: []
          });
          line.trains.push({
            id: nextTrainId++,
            line: line,
            direction: -1,
            currentSegment: line.stations.length - 2,
            progress: 0,
            state: "dwell",
            dwellStart: now,
            travelTime: 0,
            onboard: []
          });
        } else {
          let idx1 = 0;
          let idx2 = Math.floor((line.stations.length - 1) / 2);
          line.trains.push({
            id: nextTrainId++,
            line: line,
            direction: 1,
            currentSegment: idx1,
            progress: 0,
            state: "dwell",
            dwellStart: now,
            travelTime: 0,
            onboard: []
          });
          line.trains.push({
            id: nextTrainId++,
            line: line,
            direction: -1,
            currentSegment: idx2,
            progress: 0,
            state: "dwell",
            dwellStart: now,
            travelTime: 0,
            onboard: []
          });
        }
      }

      function updateTrains(now){
        for(let line of metroLines){
          // Guard: if line has fewer than 2 stations, skip.
          if(line.stations.length < 2) continue;
          for(let train of line.trains){
            // Clamp train.currentSegment to valid index.
            if(train.currentSegment < 0) train.currentSegment = 0;
            if(train.currentSegment > line.stations.length - 2) train.currentSegment = line.stations.length - 2;
            let from, to;
            if(train.direction === 1){
              from = line.stations[train.currentSegment];
              to = line.stations[train.currentSegment+1];
            } else {
              from = line.stations[train.currentSegment+1];
              to = line.stations[train.currentSegment];
            }
            // If for any reason from or to is undefined, skip update for this train.
            if(!from || !to) continue;
            let segLength = distance(from.x, from.y, to.x, to.y);
            if(train.state === "dwell"){
              if(now - train.dwellStart >= dwellTime){
                train.travelTime = computeTravelTime(segLength);
                train.state = "moving";
                train.departureTime = now;
              }
            } else if(train.state === "moving"){
              let elapsed = now - train.departureTime;
              let p = elapsed / train.travelTime;
              let ease = 0.5 - 0.5 * Math.cos(Math.PI * Math.min(p, 1));
              train.progress = ease;
              if(p >= 1){
                // Arrived at destination of current segment.
                if(line.isLoop){
                  train.currentSegment = (train.currentSegment + train.direction) % (line.stations.length - 1);
                  if(train.currentSegment < 0) train.currentSegment += (line.stations.length - 1);
                } else {
                  if(train.direction === 1 && train.currentSegment === line.stations.length - 2){
                    train.direction = -1;
                  } else if(train.direction === -1 && train.currentSegment === 0){
                    train.direction = 1;
                  } else {
                    train.currentSegment += train.direction;
                  }
                }
                train.state = "dwell";
                train.dwellStart = now;
                train.progress = 0;
              }
            }
          }
        }
      }

      // ========= COMMUTER SIMULATION =========
      // Build a graph from all metro line segments.
      function buildGraph(){
        let graph = {};
        for(let s of stations) graph[s.id] = [];
        for(let line of metroLines){
          for(let i = 0; i < line.stations.length - 1; i++){
            let a = line.stations[i], b = line.stations[i+1];
            graph[a.id].push({ station: b, line: line });
            graph[b.id].push({ station: a, line: line });
          }
        }
        return graph;
      }

      // BFS to compute a route from start to goal.
      // Returns an array of segments: { from, to, line }
      function computeRoute(start, goal){
        let graph = buildGraph();
        let queue = [ start ];
        let visited = {};
        visited[start.id] = null;
        while(queue.length){
          let current = queue.shift();
          if(current === goal) break;
          for(let edge of graph[current.id]){
            if(!(edge.station.id in visited)){
              visited[edge.station.id] = { from: current, line: edge.line };
              queue.push(edge.station);
            }
          }
        }
        if(!(goal.id in visited)) return null;
        let route = [];
        let cur = goal;
        while(cur !== start){
          let info = visited[cur.id];
          route.unshift({ from: info.from, to: cur, line: info.line });
          cur = info.from;
        }
        return route;
      }

      // Spawn a commuter at a random station with a random destination.
      function spawnCommuter(){
        if(stations.length < 2) return;
        let start = stations[Math.floor(Math.random()*stations.length)];
        let dest;
        do {
          dest = stations[Math.floor(Math.random()*stations.length)];
        } while(dest === start);
        let route = computeRoute(start, dest);
        let commuter = {
          id: nextCommuterId++,
          currentStation: start,
          destinationStation: dest,
          state: "waiting",  // "waiting" or "inTrain"
          route: route
        };
        commuters.push(commuter);
      }

      function updateCommuters(now){
        // Recalculate routes every update.
        for(let commuter of commuters){
          if(commuter.state === "waiting"){
            commuter.route = computeRoute(commuter.currentStation, commuter.destinationStation);
            if(commuter.route && commuter.route.length > 0){
              let seg = commuter.route[0];
              // Look for a train on seg.line dwelling at commuter.currentStation.
              let candidate = seg.line.trains.find(train => {
                if(train.state !== "dwell") return false;
                let posStation = (train.direction === 1) ? seg.line.stations[train.currentSegment] : seg.line.stations[train.currentSegment+1];
                return posStation && posStation.id === commuter.currentStation.id;
              });
              if(candidate){
                commuter.state = "inTrain";
                candidate.onboard = candidate.onboard || [];
                candidate.onboard.push(commuter);
              }
            }
          }
        }
        // Disembark passengers when a train's dwell period ends.
        for(let line of metroLines){
          for(let train of line.trains){
            if(train.state === "dwell" && (now - train.dwellStart >= dwellTime) && train.onboard.length > 0){
              let currentStation = (train.direction === 1) ? line.stations[train.currentSegment] : line.stations[train.currentSegment+1];
              // For each onboard commuter, if they've reached their destination, mark them as arrived.
              train.onboard.forEach(commuter => {
                if(commuter.route && commuter.route.length > 0 && commuter.route[0].to.id === currentStation.id){
                  commuter.currentStation = currentStation;
                  // If this is the destination, count arrival and add effect.
                  if(commuter.destinationStation.id === currentStation.id){
                    arrivedCount++;
                    arrivalEffects.push({ x: currentStation.x, y: currentStation.y, startTime: now });
                    commuter.arrived = true;
                  } else {
                    commuter.state = "waiting";
                  }
                  commuter.route.shift();
                }
              });
              train.onboard = [];
            }
          }
        }
        // Remove arrived commuters.
        commuters = commuters.filter(c => !c.arrived && c.currentStation.id !== c.destinationStation.id);
        // Update global counter.
        counterDiv.textContent = "Arrived: " + arrivedCount;
      }

      // ========= DRAWING FUNCTIONS =========

      // For lines sharing the same segment, compute an offset.
      function getSegmentOffset(line, segmentIndex){
        let a = line.stations[segmentIndex], b = line.stations[segmentIndex+1];
        let sameSegmentLines = metroLines.filter(l => {
          for(let i = 0; i < l.stations.length - 1; i++){
            let p = l.stations[i], q = l.stations[i+1];
            if((p.id === a.id && q.id === b.id) || (p.id === b.id && q.id === a.id)) return true;
          }
          return false;
        });
        sameSegmentLines.sort((l1, l2) => l1.id - l2.id);
        let idx = sameSegmentLines.findIndex(l => l.id === line.id);
        let count = sameSegmentLines.length;
        let offsetDistance = 10;
        let offset = (count % 2 === 1)
          ? (idx - Math.floor(count/2)) * offsetDistance
          : (idx - count/2 + 0.5) * offsetDistance;
        return offset;
      }

      function drawStations(){
        for(let s of stations){
          ctx.beginPath();
          ctx.arc(s.x, s.y, stationRadius, 0, 2 * Math.PI);
          ctx.fillStyle = "#FFF";
          ctx.fill();
          ctx.strokeStyle = "#000";
          ctx.stroke();
          ctx.fillStyle = "#000";
          ctx.font = "12px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(s.id, s.x, s.y);
        }
      }

      function drawMetroLines(){
        for(let line of metroLines){
          ctx.beginPath();
          ctx.lineWidth = 4;
          ctx.strokeStyle = line.color;
          for(let i = 0; i < line.stations.length - 1; i++){
            let s1 = line.stations[i];
            let s2 = line.stations[i+1];
            let offset = getSegmentOffset(line, i);
            let dx = s2.x - s1.x, dy = s2.y - s1.y;
            let len = Math.sqrt(dx*dx + dy*dy);
            let offX = -dy/len * offset;
            let offY = dx/len * offset;
            let startX = s1.x + offX;
            let startY = s1.y + offY;
            let endX = s2.x + offX;
            let endY = s2.y + offY;
            if(i === 0) ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
          }
          ctx.stroke();
          ctx.lineWidth = 2;
        }
      }

      function drawActiveLine(){
        if(activeLine){
          if(activeLine.editingMode === "new"){
            ctx.beginPath();
            ctx.lineWidth = 4;
            ctx.strokeStyle = activeLine.color;
            for(let i = 0; i < activeLine.stations.length; i++){
              let s = activeLine.stations[i];
              if(i === 0) ctx.moveTo(s.x, s.y);
              else ctx.lineTo(s.x, s.y);
            }
            if(activeLine.stations.length > 0){
              ctx.lineTo(currentMousePos.x, currentMousePos.y);
            }
            ctx.stroke();
            ctx.lineWidth = 2;
          } else if(activeLine.editingMode === "modify"){
            ctx.save();
            ctx.globalAlpha = 0.3;
            ctx.beginPath();
            ctx.strokeStyle = activeLine.color;
            for(let i = 0; i < activeLine.originalStations.length; i++){
              let s = activeLine.originalStations[i];
              if(i === 0) ctx.moveTo(s.x, s.y);
              else ctx.lineTo(s.x, s.y);
            }
            ctx.stroke();
            ctx.restore();
            let tempStations = activeLine.originalStations.slice();
            let idx = activeLine.modifySegmentIndex;
            tempStations.splice(idx+1, 0, activeLine.modifyCursor);
            ctx.beginPath();
            ctx.lineWidth = 4;
            ctx.strokeStyle = activeLine.color;
            for(let i = 0; i < tempStations.length; i++){
              let p = tempStations[i];
              if(i === 0) ctx.moveTo(p.x, p.y);
              else ctx.lineTo(p.x, p.y);
            }
            ctx.stroke();
            ctx.lineWidth = 2;
          }
        }
      }

      function drawTrains(){
        let trainsBySegment = {};
        for(let line of metroLines){
          for(let train of line.trains){
            let key = line.id + "_" + train.currentSegment;
            if(!trainsBySegment[key]) trainsBySegment[key] = [];
            trainsBySegment[key].push(train);
          }
        }
        for(let key in trainsBySegment){
          let group = trainsBySegment[key];
          group.sort((a, b) => a.id - b.id);
          let count = group.length;
          group.forEach((train, idx) => {
            let offsetDistance = 6;
            let offset = (count % 2 === 1)
              ? (idx - Math.floor(count/2)) * offsetDistance
              : (idx - count/2 + 0.5) * offsetDistance;
            let from, to;
            if(train.direction === 1){
              from = train.line.stations[train.currentSegment];
              to = train.line.stations[train.currentSegment+1];
            } else {
              from = train.line.stations[train.currentSegment+1];
              to = train.line.stations[train.currentSegment];
            }
            let x = from.x + (to.x - from.x) * train.progress;
            let y = from.y + (to.y - from.y) * train.progress;
            let dx = to.x - from.x, dy = to.y - from.y;
            let len = Math.sqrt(dx*dx + dy*dy);
            let offX = -dy/len * getSegmentOffset(train.line, train.currentSegment);
            let offY = dx/len * getSegmentOffset(train.line, train.currentSegment);
            let addOffX = -dy/len * offset;
            let addOffY = dx/len * offset;
            x += offX + addOffX;
            y += offY + addOffY;
            let angle = Math.atan2(to.y - from.y, to.x - from.x);
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.fillStyle = "green";
            ctx.fillRect(-trainWidth/2, -trainHeight/2, trainWidth, trainHeight);
            ctx.strokeStyle = "black";
            ctx.strokeRect(-trainWidth/2, -trainHeight/2, trainWidth, trainHeight);
            // Draw onboard passengers inside the train.
            if(train.onboard && train.onboard.length > 0){
              let n = train.onboard.length;
              let spacing = trainWidth / (n + 1);
              for(let i = 0; i < n; i++){
                let paxOffsetX = -trainWidth/2 + spacing*(i+1);
                let paxOffsetY = 0;
                ctx.beginPath();
                ctx.arc(paxOffsetX, paxOffsetY, 3, 0, 2*Math.PI);
                ctx.fillStyle = "blue";
                ctx.fill();
                ctx.fillStyle = "white";
                ctx.font = "8px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(train.onboard[i].destinationStation.id, paxOffsetX, paxOffsetY);
              }
            }
            ctx.restore();
          });
        }
      }

      function drawCommuters(){
        let waitingByStation = {};
        for(let commuter of commuters){
          if(commuter.state === "waiting"){
            let id = commuter.currentStation.id;
            if(!waitingByStation[id]) waitingByStation[id] = [];
            waitingByStation[id].push(commuter);
          }
        }
        for(let stationId in waitingByStation){
          let group = waitingByStation[stationId];
          group.sort((a, b) => a.id - b.id);
          let spacing = 12;
          let station = stations.find(s => s.id === stationId);
          for(let i = 0; i < group.length; i++){
            let offset = (i - (group.length - 1)/2) * spacing;
            let x = station.x + offset;
            let y = station.y;
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, 2*Math.PI);
            ctx.fillStyle = "blue";
            ctx.fill();
            ctx.fillStyle = "red";
            ctx.font = "bold 12px Arial";
            ctx.textAlign = "left";
            ctx.textBaseline = "middle";
            ctx.fillText("→ " + group[i].destinationStation.id, x + 8, y - 10);
          }
        }
      }

      function drawHoveredRoute(){
        if(hoveredCommuter && hoveredCommuter.route){
          ctx.save();
          ctx.strokeStyle = "orange";
          ctx.lineWidth = 3;
          ctx.setLineDash([5,5]);
          for(let seg of hoveredCommuter.route){
            ctx.beginPath();
            ctx.moveTo(seg.from.x, seg.from.y);
            ctx.lineTo(seg.to.x, seg.to.y);
            ctx.stroke();
          }
          ctx.restore();
        }
      }

      // Draw arrival effects (a "tada" burst).
      function drawArrivalEffects(now){
        for(let i = arrivalEffects.length - 1; i >= 0; i--){
          let effect = arrivalEffects[i];
          let dt = now - effect.startTime;
          let duration = 1000;
          if(dt > duration){
            arrivalEffects.splice(i, 1);
          } else {
            let progress = dt / duration;
            let alpha = 1 - progress;
            let radius = 20 + 20 * progress;
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, radius, 0, 2 * Math.PI);
            ctx.strokeStyle = "gold";
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.restore();
          }
        }
      }

      function draw(){
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawMetroLines();
        drawActiveLine();
        drawStations();
        drawTrains();
        drawCommuters();
        drawHoveredRoute();
        drawArrivalEffects(performance.now());
      }

      // ========= UPDATE LOOP =========
      function update(now){
        updateTrains(now);
        updateCommuters(now);
        draw();
        requestAnimationFrame(update);
      }

      // ========= INITIALIZATION =========
      initStations();
      setInterval(spawnCommuter, commuterSpawnInterval);
      requestAnimationFrame(update);
    })();
  </script>
</body>
</html>
