<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Metro System Designer & Simulator – Multi‑Modal</title>
  <style>
    body { font-family: sans-serif; margin:0; padding:0; }
    canvas { border: 1px solid #000; display: block; margin: 0 auto; }
    #controls { margin: 10px; }
    #controls > * { margin-right: 10px; }
    #counter { position: absolute; top: 10px; right: 10px; font-size: 18px; font-weight: bold; background: rgba(255,255,255,0.8); padding: 5px 10px; border: 1px solid #000; }
    #trainPopup {
      position: absolute;
      background: rgba(255,255,255,0.95);
      border: 1px solid #000;
      padding: 5px;
      display: none;
      pointer-events: none;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div id="controls">
    <label for="lineColorDropdown">Line Color:</label>
    <select id="lineColorDropdown">
      <option value="#ff0000" selected>Red</option>
      <option value="#0000ff">Blue</option>
      <option value="#00ff00">Green</option>
      <option value="#ffff00">Yellow</option>
      <option value="#800080">Purple</option>
      <option value="#ffa500">Orange</option>
      <option value="#00ffff">Cyan</option>
      <option value="#ff00ff">Magenta</option>
      <option value="#8b4513">Brown</option>
      <option value="#000000">Black</option>
    </select>
    <button id="newLineButton">New Line</button>
    <button id="deleteLineButton">Delete Line</button>
  </div>
  <div id="counter">Arrived: 0</div>
  <div id="trainPopup"></div>
  <p style="margin:10px;">
    <strong>How to use:</strong><br>
    • Draw/modify metro lines as before (with draggable endpoint tabs).<br>
    • Stations are created manually by double‑clicking an intersection and removed via right‑click.<br>
    • Commuters spawn at random intersections and recalc their fastest route (mixing walking and metro) whenever the metro changes. When a walking edge transitions into metro, the commuter computes a target stop—the final station of the contiguous metro ride.<br>
    • Each commuter’s state (walking, waitingForTrain, riding, or transferring) is shown when highlighted (hovered or pinned).<br>
    • When a train completes its move, it checks onboard commuters; if a commuter’s target stop matches the arrival station, they disembark (removing the metro edges they’ve just ridden). If more metro edges remain, they enter a transferring state (with a fixed delay) before boarding the next train.<br>
    • Enjoy the multi‑modal simulation!
  </p>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <script>
    (function(){
      // === CONFIGURATION ===
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      // Metro/Train constants:
      const acceleration = 0.0005;
      const maxSpeed = 1.0; // px/frame
      const dwellTime = 2000;
      const trainWidth = 30, trainHeight = 15;
      // Station and line drawing:
      const stationRadius = 15;
      const snapThreshold = 20;
      const tabMargin = 10;
      const tabRadius = 6;
      // Commuter/Walking constants:
      const commuterSpawnInterval = 1500;
      const walkingSpeed = 0.05; // px/frame
      // Grid parameters:
      const gridSpacing = 50;
      const canvasCols = Math.floor(canvas.width / gridSpacing) + 1;
      const canvasRows = Math.floor(canvas.height / gridSpacing) + 1;
      // Station management:
      const maxStationCount = 26;
      // Default metro wait time (for loops):
      const metroWaitTime = dwellTime / 2;
      // Transfer delay in ms:
      const transferTime = 3000;
      
      // === GLOBAL STATE ===
      let stations = [];  // { id, x, y, col, row }
      let metroLines = []; // { id, color, stations: [...], trains: [], isLoop }
      let activeLine = null; // for new, modify, or extend modes
      let commuters = []; // Each commuter: { id, startNode, goalNode, destinationStation, route, currentEdgeIndex, progress, state, position, lastUpdate, targetStop, transferStart }
      let nextLineId = 1, nextTrainId = 1, nextCommuterId = 1;
      let arrivedCount = 0;
      let arrivalEffects = []; // { x, y, startTime }
      let hoveredCommuter = null;
      let pinnedCommuter = null;  // For commuter pinning
      let hoveredTrain = null;
      const trainPopup = document.getElementById('trainPopup');
      
      // === UI ELEMENTS ===
      const lineColorDropdown = document.getElementById('lineColorDropdown');
      const newLineButton = document.getElementById('newLineButton');
      const deleteLineButton = document.getElementById('deleteLineButton');
      const counterDiv = document.getElementById('counter');
      
      // --- Toggle New Line Mode ---
      newLineButton.addEventListener('click', () => {
        if(activeLine && activeLine.editingMode === "new"){
          activeLine = null;
        } else {
          activeLine = {
            id: nextLineId++,
            color: lineColorDropdown.value,
            stations: [],
            trains: [],
            editingMode: "new"
          };
        }
      });
      deleteLineButton.addEventListener('click', () => {
        metroLines = metroLines.filter(line => line.color !== lineColorDropdown.value);
        recalcCommuterRoutes();
      });
      
      // === STATION MANAGEMENT ===
      const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      let validIntersections = [];
      for (let col = 0; col < canvasCols; col++){
        for (let row = 0; row < canvasRows; row++){
          validIntersections.push({ col, row, x: col * gridSpacing, y: row * gridSpacing });
        }
      }
      // (Stations are created manually via double‑click.)
      
      // === OFFSCREEN BACKGROUND ===
      const bgCanvas = document.createElement("canvas");
      bgCanvas.width = canvas.width;
      bgCanvas.height = canvas.height;
      const bgCtx = bgCanvas.getContext("2d");
      function rectanglesOverlap(r1, r2) {
        return !(r2.x >= r1.x + r1.width ||
                 r2.x + r2.width <= r1.x ||
                 r2.y >= r1.y + r1.height ||
                 r2.y + r2.height <= r1.y);
      }
      function createBackground(){
        bgCtx.save();
        bgCtx.strokeStyle = "#e0e0e0";
        bgCtx.lineWidth = 1;
        for(let x = 0; x <= bgCanvas.width; x += gridSpacing){
          bgCtx.beginPath();
          bgCtx.moveTo(x, 0);
          bgCtx.lineTo(x, bgCanvas.height);
          bgCtx.stroke();
        }
        for(let y = 0; y <= bgCanvas.height; y += gridSpacing){
          bgCtx.beginPath();
          bgCtx.moveTo(0, y);
          bgCtx.lineTo(bgCanvas.width, y);
          bgCtx.stroke();
        }
        const placedRects = [];
        const maxRects = 25;
        let attempts = 0;
        const maxAttempts = maxRects * 10;
        while(placedRects.length < maxRects && attempts < maxAttempts) {
          let bx = Math.random() * bgCanvas.width;
          let by = Math.random() * bgCanvas.height;
          let bWidth = 40 + Math.random() * 60;
          let bHeight = 40 + Math.random() * 60;
          if(bx + bWidth > bgCanvas.width) bx = bgCanvas.width - bWidth;
          if(by + bHeight > bgCanvas.height) by = bgCanvas.height - bHeight;
          const newRect = { x: bx, y: by, width: bWidth, height: bHeight };
          let overlap = placedRects.some(rect => rectanglesOverlap(newRect, rect));
          if (!overlap) { placedRects.push(newRect); }
          attempts++;
        }
        placedRects.forEach(rect => {
          bgCtx.fillStyle = "rgba(200,200,200,0.3)";
          bgCtx.fillRect(rect.x, rect.y, rect.width, rect.height);
        });
        bgCtx.restore();
      }
      createBackground();
      
      // === GRID NODES FOR PATHPLANNING ===
      let gridNodes = {};
      for(let col = 0; col < canvasCols; col++){
        for(let row = 0; row < canvasRows; row++){
          let key = col + "," + row;
          gridNodes[key] = { col, row, x: col * gridSpacing, y: row * gridSpacing };
        }
      }
      
      // === HELPER FUNCTIONS ===
      function distance(x1, y1, x2, y2){
        return Math.hypot(x2 - x1, y2 - y1);
      }
      function getStationAt(x, y){
        for(let s of stations){
          if(distance(x, y, s.x, s.y) < stationRadius) return s;
        }
        return null;
      }
      function getSnappedStation(x, y){
        for(let s of stations){
          if(distance(x, y, s.x, s.y) < snapThreshold) return s;
        }
        return null;
      }
      function distanceToSegment(px, py, x1, y1, x2, y2){
        const l2 = Math.pow(distance(x1, y1, x2, y2), 2);
        if(l2 === 0) return distance(px, py, x1, y1);
        let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2;
        t = Math.max(0, Math.min(1, t));
        return distance(px, py, x1 + t * (x2 - x1), y1 + t * (y2 - y1));
      }
      function computeTravelTime(d){
        const t_acc = maxSpeed / acceleration;
        const d_acc = 0.5 * acceleration * t_acc * t_acc;
        if(d >= 2 * d_acc){
          let t_cruise = (d - 2 * d_acc) / maxSpeed;
          return t_acc + t_cruise + t_acc;
        } else {
          return 2 * Math.sqrt(d / acceleration);
        }
      }
      function darkenColor(hex, factor) {
        let r = parseInt(hex.slice(1, 3), 16);
        let g = parseInt(hex.slice(3, 5), 16);
        let b = parseInt(hex.slice(5, 7), 16);
        r = Math.floor(r * factor);
        g = Math.floor(g * factor);
        b = Math.floor(b * factor);
        return "#" + ("0" + r.toString(16)).slice(-2) +
                     ("0" + g.toString(16)).slice(-2) +
                     ("0" + b.toString(16)).slice(-2);
      }
      function computeTabPosition(line, endpointType){
        let tab = { x: 0, y: 0 };
        if(line.stations.length < 2) return tab;
        if(endpointType === "end"){
          let last = line.stations[line.stations.length - 1];
          let prev = line.stations[line.stations.length - 2];
          let dx = last.x - prev.x, dy = last.y - prev.y;
          let len = Math.sqrt(dx * dx + dy * dy);
          let dirX = dx / len, dirY = dy / len;
          tab.x = last.x + dirX * (stationRadius + tabMargin);
          tab.y = last.y + dirY * (stationRadius + tabMargin);
        } else if(endpointType === "start"){
          let first = line.stations[0];
          let next = line.stations[1];
          let dx = first.x - next.x, dy = first.y - next.y;
          let len = Math.sqrt(dx * dx + dy * dy);
          let dirX = dx / len, dirY = dy / len;
          tab.x = first.x + dirX * (stationRadius + tabMargin);
          tab.y = first.y + dirY * (stationRadius + tabMargin);
        }
        return tab;
      }
      
      // === TRAIN SIMULATION FUNCTIONS ===
      function spawnDefaultTrains(line){
        line.trains = [];
        let now = performance.now();
        if(!line.isLoop){
          line.trains.push({
            id: nextTrainId++,
            line: line,
            direction: 1,
            currentSegment: 0,
            progress: 0,
            state: "dwell",
            dwellStart: now,
            travelTime: 0,
            onboard: [],
            originalSegment: null,
            position: {x: line.stations[0].x, y: line.stations[0].y}
          });
          line.trains.push({
            id: nextTrainId++,
            line: line,
            direction: -1,
            currentSegment: line.stations.length - 2,
            progress: 0,
            state: "dwell",
            dwellStart: now,
            travelTime: 0,
            onboard: [],
            originalSegment: null,
            position: {x: line.stations[line.stations.length - 2].x, y: line.stations[line.stations.length - 2].y}
          });
        } else {
          line.trains.push({
            id: nextTrainId++,
            line: line,
            direction: 1,
            currentSegment: 0,
            progress: 0,
            state: "dwell",
            dwellStart: now,
            travelTime: 0,
            onboard: [],
            originalSegment: null,
            position: {x: line.stations[0].x, y: line.stations[0].y}
          });
          line.trains.push({
            id: nextTrainId++,
            line: line,
            direction: -1,
            currentSegment: 0,
            progress: 0,
            state: "dwell",
            dwellStart: now,
            travelTime: 0,
            onboard: [],
            originalSegment: null,
            position: {x: line.stations[0].x, y: line.stations[0].y}
          });
        }
      }

      function offloadPassengers(train, now) {
        let line = train.line;
        let arrivalStation = train.originalSegment ? train.originalSegment.to : to;
        // For each onboard commuter, if their targetStop matches arrivalStation, they disembark.
        // For each onboard commuter, check if it’s time to get off.
        train.onboard.forEach(commuter => {
          // all commuters should move to next edge
          if (commuter.route && commuter.route[commuter.currentEdgeIndex] && 
            commuter.route[commuter.currentEdgeIndex].mode === "metro" &&
            commuter.route[commuter.currentEdgeIndex].to.id === arrivalStation.id
          ) {
            commuter.currentEdgeIndex += 1;
          }
          // If this is the commuter's target stop, they disembark.
          if(commuter.state === "riding" && commuter.targetStop && commuter.targetStop.id === arrivalStation.id){
            if (pinnedCommuter == commuter) {
              console.log("commuter disembarks:", commuter);
            }
            commuter.targetStop = null;
            commuter.currentStation = arrivalStation;
            if (commuter.currentEdgeIndex >= commuter.route.length) {
              // Finished their route.
              commuter.arrived = true;
              arrivedCount++;
              arrivalEffects.push({ x: arrivalStation.x, y: arrivalStation.y, startTime: now });
            } else {
              commuter.position = commuter.route[commuter.currentEdgeIndex].from;
              // if the next edge is a metro edge, enter transferring state.
              if(commuter.route[commuter.currentEdgeIndex].mode === "metro"){
                commuter.state = "transferring";
                commuter.transferStart = now;
              } else {
                commuter.state = "walking";
                commuter.progress = 0;
              }
            }
          }
        });
        // Filter out those who disembarked.
        train.onboard = train.onboard.filter(commuter => commuter.state === "riding");
        train.originalSegment = null;
        if(!line.isLoop){
          if(train.direction === 1 && train.currentSegment === line.stations.length - 2){
            train.direction = -1;
          } else if(train.direction === -1 && train.currentSegment === 0){
            train.direction = 1;
          } else {
            train.currentSegment += train.direction;
          }
        } else {
          train.currentSegment = (train.currentSegment + train.direction) % (line.stations.length - 1);
          if(train.currentSegment < 0) train.currentSegment += (line.stations.length - 1);
        }
        train.state = "dwell";
        train.dwellStart = now;
      }
      
      function updateTrains(now){
        metroLines.forEach(line => {
          if(line.stations.length < 2) return;
          line.trains.forEach(train => {
            if(train.currentSegment < 0) train.currentSegment = 0;
            if(train.currentSegment > line.stations.length - 2) train.currentSegment = line.stations.length - 2;
            let from, to;
            if(train.direction === 1){
              from = line.stations[train.currentSegment];
              to = line.stations[train.currentSegment+1];
            } else {
              from = line.stations[train.currentSegment+1];
              to = line.stations[train.currentSegment];
            }
            if(!from || !to) return;
            let segLength = distance(from.x, from.y, to.x, to.y);
            if(train.state === "dwell"){
              if(now - train.dwellStart >= dwellTime){
                train.travelTime = computeTravelTime(segLength);
                train.state = "moving";
                train.departureTime = now;
                train.originalSegment = { from: { ...from }, to: { ...to }, travelTime: train.travelTime };
              }
            } else if(train.state === "moving"){
              let dx = to.x - from.x, dy = to.y - from.y;
              let normalized_dx = dx / segLength, normalized_dy = dy / segLength;
              let d = distance(train.position.x, train.position.y, to.x, to.y);
              if (d < maxSpeed) {
                // we reached the next station
                train.position = { x: to.x, y: to.y };
                offloadPassengers(train, now);
              } else {
                train.position = { 
                  x: train.position.x + normalized_dx * maxSpeed,
                  y: train.position.y + normalized_dy * maxSpeed,
                };
              }
              
              // Update onboard commuters' positions so they ride along.
              train.onboard.forEach(commuter => {
                commuter.position = { x: train.position.x, y: train.position.y };
              });
            }
          });
        });
      }
      
      // === COMMUTER PATHPLANNING (Road + Metro) ===
      function buildRoadGraph(){
        let graph = {};
        for(let key in gridNodes) { 
          graph[key] = []; 
        }
        // Walking edges:
        for(let key in gridNodes) {
          let node = gridNodes[key];
          let neighbors = [
            { col: node.col+1, row: node.row },
            { col: node.col-1, row: node.row },
            { col: node.col, row: node.row+1 },
            { col: node.col, row: node.row-1 }
          ];
          neighbors.forEach(n => {
            let nKey = n.col + "," + n.row;
            if(gridNodes[nKey]){
              let d = distance(node.x, node.y, gridNodes[nKey].x, gridNodes[nKey].y);
              graph[key].push({ 
                from: node, 
                to: gridNodes[nKey], 
                mode: "walk", 
                cost: d / walkingSpeed 
              });
            }
          });
        }
        // Metro edges:
        metroLines.forEach(line => {
          for(let i = 0; i < line.stations.length - 1; i++){
            let a = line.stations[i], b = line.stations[i+1];
            let keyA = a.col + "," + a.row;
            let keyB = b.col + "," + b.row;
            if(gridNodes[keyA] && gridNodes[keyB]){
              let d = distance(a.x, a.y, b.x, b.y);
              let waitingTime;
              if(!line.isLoop){
                let totalDistance = 0;
                for(let j = 0; j < line.stations.length - 1; j++){
                  totalDistance += distance(line.stations[j].x, line.stations[j].y, line.stations[j+1].x, line.stations[j+1].y);
                }
                let numTrains = (line.trains && line.trains.length) ? line.trains.length : 1;
                waitingTime = (2 * totalDistance) / (numTrains * maxSpeed);
              } else {
                waitingTime = metroWaitTime;
              }
              let metroCost = computeTravelTime(d) + waitingTime;
              // Use station objects directly so they include an "id"
              graph[keyA].push({ 
                from: a, 
                to: b, 
                mode: "metro", 
                cost: metroCost, 
                line 
              });
              graph[keyB].push({ 
                from: b, 
                to: a, 
                mode: "metro", 
                cost: metroCost, 
                line 
              });
            }
          }
        });

        return graph;
      }
      
      function computeFastestRoute(startNode, goalNode){
        let graph = buildRoadGraph();
        let startKey = startNode.col + "," + startNode.row;
        let goalKey = goalNode.col + "," + goalNode.row;
        let dist = {};
        let prev = {};
        for(let key in graph) { dist[key] = Infinity; }
        dist[startKey] = 0;
        let pq = [{ key: startKey, cost: 0 }];
        while(pq.length){
          pq.sort((a, b) => a.cost - b.cost);
          let current = pq.shift();
          if(current.key === goalKey) break;
          graph[current.key].forEach(edge => {
            let neighborKey = edge.to.col + "," + edge.to.row;
            let alt = dist[current.key] + edge.cost;
            if(alt < dist[neighborKey]){
              dist[neighborKey] = alt;
              prev[neighborKey] = { from: current.key, edge };
              pq.push({ key: neighborKey, cost: alt });
            }
          });
        }
        let route = [];
        let curKey = goalKey;
        while(curKey && curKey !== startKey){
          if(prev[curKey]){
            route.unshift(prev[curKey].edge);
            curKey = prev[curKey].from;
          } else { break; }
        }
        return route;
      }
      
      // When recalculating a commuter's route, use current position on a walking edge.
      function recalcCommuterRoutes(){
        commuters.forEach(commuter => {
          if(commuter.state === "walking" || commuter.state === "waitingForTrain"){
            if(commuter.route && commuter.currentEdgeIndex < commuter.route.length && commuter.route[commuter.currentEdgeIndex].mode === "walk"){
              let edge = commuter.route[commuter.currentEdgeIndex];
              let endpoint = edge.to;
              let tempEdge = {
                from: { x: commuter.position.x, y: commuter.position.y },
                to: endpoint,
                mode: "walk",
                cost: distance(commuter.position.x, commuter.position.y, endpoint.x, endpoint.y) / walkingSpeed
              };
              let newRouteFromEndpoint = computeFastestRoute(endpoint, commuter.goalNode);
              commuter.route = [tempEdge].concat(newRouteFromEndpoint);
              commuter.currentEdgeIndex = 0;
              commuter.progress = 0;
            } else {
              let closest = null, best = Infinity;
              for(let key in gridNodes){
                let node = gridNodes[key];
                let d = distance(commuter.position.x, commuter.position.y, node.x, node.y);
                if(d < best){ best = d; closest = node; }
              }
              if(closest){
                commuter.route = computeFastestRoute(closest, commuter.goalNode);
                commuter.currentEdgeIndex = 0;
                commuter.progress = 0;
              }
            }
          }
        });
      }
      
      // When spawning a commuter, set initial route and destination.
      function spawnCommuter(){
        let gridKeys = Object.keys(gridNodes);
        if(gridKeys.length < 2) return;
        let startKey = gridKeys[Math.floor(Math.random() * gridKeys.length)];
        let goalKey;
        do { goalKey = gridKeys[Math.floor(Math.random() * gridKeys.length)]; } while(goalKey === startKey);
        let startNode = gridNodes[startKey];
        let goalNode = gridNodes[goalKey];
        let route = computeFastestRoute(startNode, goalNode);
        if(!route || route.length === 0){
          arrivedCount++;
          return;
        }
        let commuter = {
          id: nextCommuterId++,
          startNode,
          goalNode,
          destinationStation: goalNode,
          route, // Array of edges
          currentEdgeIndex: 0,
          progress: 0,
          state: "walking",
          position: { x: startNode.x, y: startNode.y },
          lastUpdate: performance.now(),
          targetStop: null,   // To be computed when transitioning to metro
          transferStart: null // For transfer delay
        };
        commuters.push(commuter);
      }
      
      function updateCommuters(now){

        function setTargetStop(commuter){
          // if commuter is at a station or on the metro, they should always have a 'target stop' where they will get off
          // when they get off, they will either transfer to another line or walk
          let edge = commuter.route[commuter.currentEdgeIndex];
          if (edge.mode !== "metro") return;

          let target = edge.to;
          let i = commuter.currentEdgeIndex;
          let line = edge.line;
          while(i < commuter.route.length && commuter.route[i].mode === "metro" && commuter.route[i].line === line){
            target = commuter.route[i].to;
            i++;
          }

          commuter.targetStop = target;
        }

        commuters.forEach(commuter => {
          // If riding, their position is updated by the train.
          if(commuter.state === "riding"){
            return;
          } else if(commuter.state === "transferring"){
            if(now - commuter.transferStart >= transferTime){
              commuter.state = "waitingForTrain";
            }
            commuter.lastUpdate = now;
            return;
          } else if(commuter.state === "walking"){
            if(!commuter.route || commuter.currentEdgeIndex >= commuter.route.length){
              commuter.arrived = true;
              arrivedCount++;
              arrivalEffects.push({ x: commuter.position.x, y: commuter.position.y, startTime: now });
              return;
            }
            let edge = commuter.route[commuter.currentEdgeIndex];
            if(edge.mode === "walk"){
              let d = distance(edge.to.x, edge.to.y, commuter.position.x, commuter.position.y);
              if (d < walkingSpeed) {
                commuter.position = { x: edge.to.x, y: edge.to.y };
                commuter.currentEdgeIndex++;
              } else {
                let dx = edge.to.x - commuter.position.x, dy = edge.to.y - commuter.position.y;
                let normalized_dx = dx / d, normalized_dy = dy / d;
                commuter.position = {
                  x: commuter.position.x + normalized_dx * walkingSpeed,
                  y: commuter.position.y + normalized_dy * walkingSpeed
                };
              }
              // let travelTime = d / walkingSpeed;
              // let dt = now - commuter.lastUpdate;
              // commuter.progress += dt / travelTime;
              // if(commuter.progress >= 1){
              //   if (commuter == pinnedCommuter) {
              //     console.log("Pinned commuter moving to next edge");
              //   }
              //   commuter.position = { x: edge.to.x, y: edge.to.y };
              //   commuter.currentEdgeIndex++;
              //   commuter.progress = 0;
              // } else {
              //   commuter.position = {
              //     x: edge.from.x + (edge.to.x - edge.from.x) * commuter.progress,
              //     y: edge.from.y + (edge.to.y - edge.from.y) * commuter.progress
              //   };
              // }
            } else if(edge.mode === "metro"){
              setTargetStop(commuter);
              commuter.state = "waitingForTrain";
              commuter.position = { x: edge.from.x, y: edge.from.y };
              if(commuter == pinnedCommuter) {
                console.log("Pinned commuter waiting for train: ", commuter);
              }
            }
            commuter.lastUpdate = now;
          } else if(commuter.state === "waitingForTrain"){
            if(!commuter.route || commuter.currentEdgeIndex >= commuter.route.length){
              // Guard: route is empty.
              commuter.arrived = true;
              arrivedCount++;
              arrivalEffects.push({ x: commuter.position.x, y: commuter.position.y, startTime: now });
              return;
            }
            let edge = commuter.route[commuter.currentEdgeIndex];
            // If the commuter doesn't have a targetStop (e.g. after a transfer), recalc it:
            if(!commuter.targetStop && edge.mode === "metro"){
              setTargetStop(commuter);
              commuter.position = { x: edge.from.x, y: edge.from.y };
            }
            // Look for a train in dwell state at the correct station:
            if(!edge.line) return;
            let candidate = edge.line.trains.find(train => {
              if(train.state !== "dwell") return false;
              let posStation = (train.direction === 1)
                              ? train.line.stations[train.currentSegment]
                              : train.line.stations[train.currentSegment+1];
              if(posStation.col === edge.from.col && posStation.row === edge.from.row){
                if(train.direction === 1){
                  return train.line.stations[train.currentSegment+1].col === edge.to.col &&
                        train.line.stations[train.currentSegment+1].row === edge.to.row;
                } else {
                  return train.line.stations[train.currentSegment].col === edge.to.col &&
                        train.line.stations[train.currentSegment].row === edge.to.row;
                }
              }
              return false;
            });
            if(candidate){
              commuter.state = "riding";
              candidate.onboard = candidate.onboard || [];
              candidate.onboard.push(commuter);
            }
          }
        });
        commuters = commuters.filter(c => !c.arrived);
        if(pinnedCommuter && !commuters.find(c => c.id === pinnedCommuter.id)){
          pinnedCommuter = null;
        }
        counterDiv.textContent = "Arrived: " + arrivedCount;
      }
      
      // === MOUSE EVENT HANDLING ===
      let isDragging = false;
      let currentMousePos = { x: 0, y: 0 };
      
      canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        let x = e.clientX - rect.left;
        let y = e.clientY - rect.top;
        if(!activeLine){
          let clickedTab = null;
          let extendEnd = null;
          for(let line of metroLines){
            if(line.isLoop) continue;
            let tabStart = computeTabPosition(line, "start");
            let tabEnd = computeTabPosition(line, "end");
            if(distance(x, y, tabStart.x, tabStart.y) < 8){
              clickedTab = line;
              extendEnd = "start";
              break;
            } else if(distance(x, y, tabEnd.x, tabEnd.y) < 8){
              clickedTab = line;
              extendEnd = "end";
              break;
            }
          }
          if(clickedTab){
            activeLine = clickedTab;
            activeLine.editingMode = "extend";
            activeLine.extendEnd = extendEnd;
            activeLine.extendCursor = { x, y };
            activeLine.extendCandidate = null;
            isDragging = true;
            return;
          }
        }
        if(!activeLine){
          let segInfo = null;
          for(let line of metroLines){
            for(let i = 0; i < line.stations.length - 1; i++){
              let a = line.stations[i], b = line.stations[i+1];
              let d = distanceToSegment(x, y, a.x, a.y, b.x, b.y);
              if(d < 5){ segInfo = { line, segmentIndex: i }; break; }
            }
            if(segInfo) break;
          }
          if(segInfo){
            activeLine = segInfo.line;
            activeLine.editingMode = "modify";
            activeLine.modifySegmentIndex = segInfo.segmentIndex;
            activeLine.originalStations = activeLine.stations.slice();
            activeLine.modifyCursor = { x, y };
            activeLine.modifyCandidate = null;
          }
        } else if(activeLine.editingMode === "new"){
          if(activeLine.stations.length === 0){
            let s = getStationAt(x, y);
            if(s) activeLine.stations.push(s);
          }
        }
        isDragging = true;
      });
      
      canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        currentMousePos.x = e.clientX - rect.left;
        currentMousePos.y = e.clientY - rect.top;
        if(activeLine && isDragging){
          if(activeLine.editingMode === "new"){
            let snapped = getSnappedStation(currentMousePos.x, currentMousePos.y);
            if(snapped){
              let arr = activeLine.stations;
              if(snapped.id === arr[0].id && arr.length >= 2){
                if(arr[arr.length-1].id !== snapped.id) arr.push(snapped);
              } else {
                if(arr.length > 1 && arr[arr.length-2].id === snapped.id){
                  arr.pop();
                } else if(!arr.some(s => s.id === snapped.id)){
                  arr.push(snapped);
                }
              }
            }
          } else if(activeLine.editingMode === "modify"){
            let candidate = getSnappedStation(currentMousePos.x, currentMousePos.y);
            if(candidate){
              activeLine.modifyCursor = { x: candidate.x, y: candidate.y };
              activeLine.modifyCandidate = candidate;
            } else {
              activeLine.modifyCursor = { x: currentMousePos.x, y: currentMousePos.y };
              activeLine.modifyCandidate = null;
            }
          } else if(activeLine.editingMode === "extend"){
            let candidate = getSnappedStation(currentMousePos.x, currentMousePos.y);
            if(candidate){
              activeLine.extendCursor = { x: candidate.x, y: candidate.y };
              activeLine.extendCandidate = candidate;
            } else {
              activeLine.extendCursor = { x: currentMousePos.x, y: currentMousePos.y };
              activeLine.extendCandidate = null;
            }
          }
        }
        if (!pinnedCommuter) {
          hoveredCommuter = null;
          for (let commuter of commuters) {
            if((commuter.state === "walking" || commuter.state === "waitingForTrain") &&
               distance(currentMousePos.x, currentMousePos.y, commuter.position.x, commuter.position.y) < 15) {
                 hoveredCommuter = commuter;
                 break;
               }
          }
        }
      });
      
      canvas.addEventListener('mouseup', (e) => {
        isDragging = false;
        if(activeLine){
          if(activeLine.editingMode === "modify"){
            let idx = activeLine.modifySegmentIndex;
            let X = activeLine.originalStations[idx];
            let Y = activeLine.originalStations[idx+1];
            let minStations = activeLine.isLoop ? 3 : 2;
            if(activeLine.modifyCandidate){
              if((activeLine.modifyCandidate.id === X.id || activeLine.modifyCandidate.id === Y.id) && activeLine.originalStations.length > minStations){
                activeLine.stations = activeLine.originalStations.slice();
                if(activeLine.modifyCandidate.id === X.id){
                  activeLine.stations.splice(idx, 1);
                } else {
                  activeLine.stations.splice(idx+1, 1);
                }
              } else if(activeLine.modifyCandidate.id !== X.id && activeLine.modifyCandidate.id !== Y.id){
                if(!activeLine.originalStations.some(s => s.id === activeLine.modifyCandidate.id)){
                  activeLine.stations = activeLine.originalStations.slice();
                  activeLine.stations.splice(idx+1, 0, activeLine.modifyCandidate);
                } else {
                  activeLine.stations = activeLine.originalStations.slice();
                }
              } else {
                activeLine.stations = activeLine.originalStations.slice();
              }
            }
            activeLine.editingMode = "new";
            activeLine = null;
            recalcCommuterRoutes();
          } else if(activeLine.editingMode === "extend"){
            if(activeLine.extendCandidate){
              if(activeLine.extendEnd === "end"){
                if(activeLine.extendCandidate.id === activeLine.stations[0].id && activeLine.stations.length >= 2){
                  activeLine.stations.push(activeLine.extendCandidate);
                  activeLine.isLoop = true;
                } else if(!activeLine.stations.some(s => s.id === activeLine.extendCandidate.id)){
                  activeLine.stations.push(activeLine.extendCandidate);
                }
              } else if(activeLine.extendEnd === "start"){
                if(activeLine.extendCandidate.id === activeLine.stations[activeLine.stations.length-1].id && activeLine.stations.length >= 2){
                  activeLine.stations.unshift(activeLine.extendCandidate);
                  activeLine.isLoop = true;
                } else if(!activeLine.stations.some(s => s.id === activeLine.extendCandidate.id)){
                  activeLine.stations.unshift(activeLine.extendCandidate);
                }
              }
            }
            activeLine = null;
            recalcCommuterRoutes();
          }
        }
      });
      
      canvas.addEventListener('dblclick', (e) => {
        const rect = canvas.getBoundingClientRect();
        let x = e.clientX - rect.left;
        let y = e.clientY - rect.top;
        if(activeLine && activeLine.editingMode === "new"){
          if(activeLine.stations.length >= 2){
            if(activeLine.stations[0].id === activeLine.stations[activeLine.stations.length-1].id && activeLine.stations.length >= 3){
              activeLine.isLoop = true;
            } else {
              activeLine.isLoop = false;
            }
            metroLines.push(activeLine);
            spawnDefaultTrains(activeLine);
            recalcCommuterRoutes();
          }
          activeLine = null;
        } else {
          let closest = null, bestDist = Infinity;
          for (let key in gridNodes) {
            let node = gridNodes[key];
            let d = distance(x, y, node.x, node.y);
            if(d < bestDist){ bestDist = d; closest = node; }
          }
          if(bestDist < snapThreshold){
            let exists = stations.find(s => s.col === closest.col && s.row === closest.row);
            if(!exists){
              let newStation = { id: letters[stations.length], x: closest.x, y: closest.y, col: closest.col, row: closest.row };
              stations.push(newStation);
              recalcCommuterRoutes();
            }
          }
        }
      });
      
      canvas.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        let x = e.clientX - rect.left;
        let y = e.clientY - rect.top;
        let stationToRemove = null;
        for(let s of stations){
          if(distance(x, y, s.x, s.y) < snapThreshold){
            stationToRemove = s;
            break;
          }
        }
        if(stationToRemove){
          stations = stations.filter(s => s !== stationToRemove);
          metroLines.forEach(line => {
            line.stations = line.stations.filter(s => s.id !== stationToRemove.id);
          });
          recalcCommuterRoutes();
        }
      });
      
      canvas.addEventListener('click', (e) => {
        if(activeLine) return;
        const rect = canvas.getBoundingClientRect();
        let x = e.clientX - rect.left;
        let y = e.clientY - rect.top;
        let found = null;
        for(let commuter of commuters){
          if(distance(x, y, commuter.position.x, commuter.position.y) < 15){
            found = commuter;
            break;
          }
        }
        if(found){
          pinnedCommuter = found;
          console.log("Pinning: ", pinnedCommuter);
        } else {
          pinnedCommuter = null;
        }
      });
      
      function drawStations(){
        stations.forEach(s => {
          ctx.beginPath();
          ctx.arc(s.x, s.y, stationRadius, 0, 2*Math.PI);
          ctx.fillStyle = "#FFF";
          ctx.fill();
          ctx.strokeStyle = "#000";
          ctx.stroke();
          ctx.fillStyle = "#000";
          ctx.font = "12px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(s.id, s.x, s.y);
        });
      }
      
      function getSegmentOffset(line, segmentIndex){
        let a = line.stations[segmentIndex], b = line.stations[segmentIndex+1];
        let sameSegmentLines = metroLines.filter(l => {
          for(let i = 0; i < l.stations.length - 1; i++){
            let p = l.stations[i], q = l.stations[i+1];
            if((p.id === a.id && q.id === b.id) || (p.id === b.id && q.id === a.id)) return true;
          }
          return false;
        });
        sameSegmentLines.sort((l1, l2) => l1.id - l2.id);
        let idx = sameSegmentLines.findIndex(l => l.id === line.id);
        let count = sameSegmentLines.length;
        let offsetDistance = 10;
        let offset = (count % 2 === 1)
          ? (idx - Math.floor(count/2)) * offsetDistance
          : (idx - count/2 + 0.5) * offsetDistance;
        return offset;
      }
      
      function drawMetroLines(){
        metroLines.forEach(line => {
          ctx.beginPath();
          ctx.lineWidth = 4;
          ctx.strokeStyle = line.color;
          for(let i = 0; i < line.stations.length - 1; i++){
            let s1 = line.stations[i], s2 = line.stations[i+1];
            let offset = getSegmentOffset(line, i);
            let dx = s2.x - s1.x, dy = s2.y - s1.y;
            let len = Math.sqrt(dx*dx + dy*dy);
            let offX = -dy/len * offset;
            let offY = dx/len * offset;
            ctx.moveTo(s1.x + offX, s1.y + offY);
            ctx.lineTo(s2.x + offX, s2.y + offY);
          }
          ctx.stroke();
          ctx.lineWidth = 2;
          if(!line.isLoop && line.stations.length >= 2){
            let startTab = computeTabPosition(line, "start");
            let endTab = computeTabPosition(line, "end");
            ctx.save();
            ctx.fillStyle = line.color;
            ctx.beginPath();
            ctx.arc(startTab.x, startTab.y, tabRadius, 0, 2*Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(endTab.x, endTab.y, tabRadius, 0, 2*Math.PI);
            ctx.fill();
            ctx.restore();
          }
        });
      }
      
      function drawActiveLine(){
        if(activeLine){
          if(activeLine.editingMode === "new"){
            ctx.beginPath();
            ctx.lineWidth = 4;
            ctx.strokeStyle = activeLine.color;
            activeLine.stations.forEach((s, i) => {
              if(i === 0) ctx.moveTo(s.x, s.y);
              else ctx.lineTo(s.x, s.y);
            });
            ctx.lineTo(currentMousePos.x, currentMousePos.y);
            ctx.stroke();
            ctx.lineWidth = 2;
          } else if(activeLine.editingMode === "modify"){
            ctx.save();
            ctx.globalAlpha = 0.3;
            ctx.beginPath();
            ctx.strokeStyle = activeLine.color;
            activeLine.originalStations.forEach((s, i) => {
              if(i === 0) ctx.moveTo(s.x, s.y);
              else ctx.lineTo(s.x, s.y);
            });
            ctx.stroke();
            ctx.restore();
            let tempStations = activeLine.originalStations.slice();
            let idx = activeLine.modifySegmentIndex;
            tempStations.splice(idx+1, 0, activeLine.modifyCursor);
            ctx.beginPath();
            ctx.lineWidth = 4;
            ctx.strokeStyle = activeLine.color;
            tempStations.forEach((p, i) => {
              if(i === 0) ctx.moveTo(p.x, p.y);
              else ctx.lineTo(p.x, p.y);
            });
            ctx.stroke();
            ctx.lineWidth = 2;
          } else if(activeLine.editingMode === "extend"){
            let endpoint = activeLine.extendEnd === "end" ? activeLine.stations[activeLine.stations.length-1] : activeLine.stations[0];
            ctx.save();
            ctx.strokeStyle = activeLine.color;
            ctx.lineWidth = 4;
            ctx.setLineDash([5,5]);
            ctx.beginPath();
            ctx.moveTo(endpoint.x, endpoint.y);
            ctx.lineTo(activeLine.extendCursor.x, activeLine.extendCursor.y);
            ctx.stroke();
            ctx.restore();
            ctx.lineWidth = 2;
          }
        }
      }
      
      // When a commuter is highlighted, show their route and state.
      function drawHoveredRoute(){
        let commuterToDraw = pinnedCommuter || hoveredCommuter;
        if(commuterToDraw && commuterToDraw.route){
          ctx.save();
          ctx.lineWidth = 3;
          ctx.setLineDash([5,5]);
          commuterToDraw.route.forEach(edge => {
            ctx.beginPath();
            if(edge.mode === "walk"){
              ctx.strokeStyle = "green";
            } else if(edge.mode === "metro"){
              ctx.strokeStyle = "blue";
            } else {
              ctx.strokeStyle = "orange";
            }
            ctx.moveTo(edge.from.x, edge.from.y);
            ctx.lineTo(edge.to.x, edge.to.y);
            ctx.stroke();
          });
          ctx.restore();
        }
      }
      
      function drawTrains(){
        hoveredTrain = null;
        metroLines.forEach(line => {
          line.trains.forEach(train => {
            ctx.beginPath();
            ctx.arc(train.position.x, train.position.y, 15, 0, 2*Math.PI);
            ctx.fillStyle = line.color;
            ctx.fill();
          });
        });
      }

      function printRoute(commuter) {
        route = commuter.route;
        if (!route || route.length === 0) return "";
        let segments = [];
        let i = 0;
        for  (i = 0; i < route.length; i++) {
          let prefix = i == commuter.currentEdgeIndex ? ">" : " ";
          let currentEdge = route[i];
          let mode = currentEdge.mode;
          let start = currentEdge.from;
          let end = currentEdge.to;
          if (mode === "walk") {
            segments.push(`${prefix} walk from ${start.col},${start.row} to ${end.col},${end.row}`);
          } else if (mode === "metro") {
            let lineColor = currentEdge.line ? currentEdge.line.color : "";
            segments.push(`${prefix} train on ${lineColor} line from ${start.id} to ${end.id}`);
          }
        }
        return segments
      }
      
      function drawCommuters(){
        commuters.forEach(commuter => {
          let isHighlighted = (pinnedCommuter && commuter.id === pinnedCommuter.id) ||
                              (hoveredCommuter && commuter.id === hoveredCommuter.id);
          ctx.beginPath();
          ctx.arc(commuter.position.x, commuter.position.y, 5, 0, 2*Math.PI);
          ctx.fillStyle = "blue";
          ctx.fill();
          if(isHighlighted){
            ctx.fillStyle = "black";
            ctx.font = "bold 10px Arial";
            ctx.fillText("State: " + commuter.state, commuter.position.x, commuter.position.y + 15);
            ctx.fillStyle = "red";
            ctx.font = "bold 12px Arial";
            ctx.textAlign = "left";
            ctx.textBaseline = "middle";
            ctx.fillText("→ " + commuter.position.x.toFixed(3) +  "," +  commuter.position.y.toFixed(3), commuter.position.x + 8, commuter.position.y);
            ctx.fillStyle = "black";
            ctx.font = "bold 10px Arial";
            let routePlan = printRoute(commuter);
            for (let i=0; i<routePlan.length; i++) {
              ctx.fillText(routePlan[i], commuter.position.x + 8, commuter.position.y - ( 15 * routePlan.length) +15 * i);
            }

          }
        });
      }
      
      function drawArrivalEffects(now){
        for(let i = arrivalEffects.length - 1; i >= 0; i--){
          let effect = arrivalEffects[i];
          let dt = now - effect.startTime;
          let duration = 1000;
          if(dt > duration){
            arrivalEffects.splice(i, 1);
          } else {
            let progress = dt / duration;
            let alpha = 1 - progress;
            let radius = 20 + 20 * progress;
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, radius, 0, 2*Math.PI);
            ctx.strokeStyle = "gold";
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.restore();
          }
        }
      }

      function drawBackground(){
        ctx.drawImage(bgCanvas, 0, 0);
      }
      
      function draw(){
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBackground();
        drawMetroLines();
        drawActiveLine();
        drawStations();
        drawTrains();
        drawCommuters();
        drawHoveredRoute();
        drawArrivalEffects(performance.now());
      }
      
      function update(now){
        updateTrains(now);
        updateCommuters(now);
        draw();
        requestAnimationFrame(update);
      }
      
      // === MAIN INITIALIZATION ===
      setInterval(spawnCommuter, commuterSpawnInterval);
      requestAnimationFrame(update);
    })();
  </script>
</body>
</html>
