<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Metro System Designer & Simulator</title>
  <style>
    body { font-family: sans-serif; }
    canvas { border: 1px solid #000; background-color: #f0f0f0; }
    #controls { margin-bottom: 10px; }
    #controls > * { margin-right: 10px; }
  </style>
</head>
<body>
  <h1>Metro System Designer & Simulator</h1>
  <div id="controls">
    <label for="lineColorDropdown">Line Color:</label>
    <select id="lineColorDropdown">
      <option value="#ff0000" selected>Red</option>
      <option value="#0000ff">Blue</option>
      <option value="#00ff00">Green</option>
      <option value="#ffff00">Yellow</option>
      <option value="#800080">Purple</option>
      <option value="#ffa500">Orange</option>
      <option value="#00ffff">Cyan</option>
      <option value="#ff00ff">Magenta</option>
      <option value="#8b4513">Brown</option>
      <option value="#000000">Black</option>
    </select>
    <button id="newLineButton">New Line</button>
    <button id="deleteLineButton">Delete Line</button>
  </div>
  <p>
    <strong>How to use:</strong> Click “New Line” then click on a station to begin a new line. As you drag, if you pass near another station the line “snaps” to it (adding it to the route). Dragging back over the previous station undoes the last addition. If you drag to the starting station (with at least 2 stops), it will complete the loop. If you later add a station to a closed loop, the code removes the duplicate starting station and re‑adds it at the end so the line remains a closed loop (i.e. no spurs).<br>
    To modify an existing line, click on one of its segments to select it and then drag to adjust. Use “Delete Line” to remove the selected line.<br>
    Commuters spawn at random stations with a target destination—this target is shown next to them (or, for onboard passengers, above the train). They board trains (only when the train is dwelling) and ride to their destination.
  </p>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <script>
    (function(){
      // ========= CONFIGURATION =========
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const stationRadius = 15;
      const snapThreshold = 20; // distance within which a station snaps
      const trainWidth = 30, trainHeight = 15;
      const dwellTime = 2000;      // ms dwell time at station
      const acceleration = 0.001;  // px/(ms^2)
      const maxSpeed = 0.3;        // px/ms
      const commuterSpawnInterval = 3000; // ms
      const stationCount = 10; // total stations

      // ========= DATA STRUCTURES =========
      let stations = [];      // each station: { id, x, y }
      let metroLines = [];    // each line: { id, color, stations: [...], trains: [], isLoop }
      // When drawing/editing a line, activeLine holds the current line (with extra property editingMode)
      let activeLine = null;

      // Commuters: { id, currentStation, destinationStation, state:"waiting"|"inTrain", route:[{line, from, to}] }
      let commuters = [];
      // Unique id counters:
      let nextLineId = 1, nextTrainId = 1, nextCommuterId = 1;

      // ========= UI ELEMENTS =========
      const lineColorDropdown = document.getElementById('lineColorDropdown');
      const newLineButton = document.getElementById('newLineButton');
      const deleteLineButton = document.getElementById('deleteLineButton');

      newLineButton.addEventListener('click', () => {
        if(activeLine) return;
        activeLine = {
          id: nextLineId++,
          color: lineColorDropdown.value,
          stations: [],
          trains: [],
          editingMode: "new"
        };
      });

      deleteLineButton.addEventListener('click', () => {
        if(activeLine && activeLine.editingMode === "edit"){
          metroLines = metroLines.filter(l => l !== activeLine);
          activeLine = null;
        }
      });

      // ========= INITIALIZE STATIONS =========
      function initStations(){
        const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        for(let i = 0; i < stationCount; i++){
          let s = {
            id: letters[i],
            x: Math.random()*(canvas.width-40) + 20,
            y: Math.random()*(canvas.height-40) + 20
          };
          stations.push(s);
        }
      }

      // ========= HELPER FUNCTIONS =========
      function distance(x1, y1, x2, y2){
        return Math.hypot(x2-x1, y2-y1);
      }

      // Returns a station if the point is within stationRadius.
      function getStationAt(x, y){
        for(let s of stations){
          if(distance(x, y, s.x, s.y) < stationRadius) return s;
        }
        return null;
      }

      // If the point is near any station (within snapThreshold), return that station.
      function getSnappedStation(x, y){
        for(let s of stations){
          if(distance(x, y, s.x, s.y) < snapThreshold) return s;
        }
        return null;
      }

      // Returns {line, segmentIndex} if (x,y) is near any line segment.
      function getLineSegmentAt(x, y){
        for(let line of metroLines){
          for(let i = 0; i < line.stations.length - 1; i++){
            let a = line.stations[i], b = line.stations[i+1];
            let d = distanceToSegment(x, y, a.x, a.y, b.x, b.y);
            if(d < 5) return { line: line, segmentIndex: i };
          }
        }
        return null;
      }

      // Distance from point (px,py) to segment from (x1,y1) to (x2,y2)
      function distanceToSegment(px, py, x1, y1, x2, y2){
        const l2 = Math.pow(distance(x1,y1,x2,y2), 2);
        if(l2 === 0) return distance(px,py,x1,y1);
        let t = ((px - x1)*(x2-x1) + (py-y1)*(y2-y1)) / l2;
        t = Math.max(0, Math.min(1, t));
        return distance(px,py, x1 + t*(x2-x1), y1 + t*(y2-y1));
      }

      // Compute travel time along a segment of length d (with acceleration/deceleration)
      function computeTravelTime(d){
        const t_acc = maxSpeed / acceleration;
        const d_acc = 0.5 * acceleration * t_acc * t_acc;
        if(d >= 2 * d_acc){
          let t_cruise = (d - 2 * d_acc) / maxSpeed;
          return t_acc + t_cruise + t_acc;
        } else {
          return 2 * Math.sqrt(d / acceleration);
        }
      }

      // ========= LINE DRAWING / EDITING =========
      let isDragging = false;
      let currentMousePos = { x: 0, y: 0 };

      canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        let x = e.clientX - rect.left;
        let y = e.clientY - rect.top;
        if(!activeLine){
          // If not drawing, try to select an existing line by clicking on one of its segments.
          let seg = getLineSegmentAt(x, y);
          if(seg){
            activeLine = seg.line;
            activeLine.editingMode = "edit";
          }
        } else {
          // If starting a new line and no station has been added yet, try to snap to a station.
          if(activeLine.stations.length === 0){
            let s = getStationAt(x, y);
            if(s) activeLine.stations.push(s);
          }
        }
        isDragging = true;
      });

      canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        currentMousePos.x = e.clientX - rect.left;
        currentMousePos.y = e.clientY - rect.top;
        if(activeLine && isDragging){
          let snapped = getSnappedStation(currentMousePos.x, currentMousePos.y);
          if(snapped){
            let arr = activeLine.stations;
            let len = arr.length;
            // If snapped station is the same as the last station, do nothing.
            if(len > 0 && snapped === arr[len-1]){
              // do nothing
            }
            // If snapping to the starting station (with at least 2 stops), complete the loop.
            else if(len >= 2 && snapped === arr[0]){
              arr.push(snapped);
            }
            // If snapping to the second-to-last station, remove the last station (undo).
            else if(len >= 2 && snapped === arr[len-2]){
              arr.pop();
            }
            // If the line is already a loop (first equals last), enforce a loop shape:
            else if(len >= 2 && arr[0] === arr[len-1]){
              arr.pop(); // remove duplicate closing station
              arr.push(snapped);
              arr.push(arr[0]); // re-close the loop
            }
            // Otherwise, add the snapped station normally.
            else {
              arr.push(snapped);
            }
          }
        }
      });

      canvas.addEventListener('mouseup', (e) => {
        isDragging = false;
      });

      // On double click, finish drawing/editing the line.
      canvas.addEventListener('dblclick', (e) => {
        if(activeLine){
          if(activeLine.stations.length >= 2){
            // Determine if it’s a loop.
            if(activeLine.stations[0] === activeLine.stations[activeLine.stations.length-1] &&
               activeLine.stations.length >= 3){
              activeLine.isLoop = true;
            } else {
              activeLine.isLoop = false;
            }
            if(activeLine.editingMode === "new"){
              metroLines.push(activeLine);
              spawnDefaultTrains(activeLine);
            }
          }
          activeLine = null;
        }
      });

      // ========= TRAIN SIMULATION =========
      // Each train: { id, line, direction (1 or -1), currentSegment (index), progress (0..1),
      // state: "dwell" or "moving", dwellStart, departureTime, travelTime, onboard: [] }
      function spawnDefaultTrains(line){
        line.trains = [];
        let now = performance.now();
        if(!line.isLoop){
          // For non-loop lines, spawn one train at each end.
          line.trains.push({
            id: nextTrainId++,
            line: line,
            direction: 1,
            currentSegment: 0,
            progress: 0,
            state: "dwell",
            dwellStart: now,
            travelTime: 0,
            onboard: []
          });
          line.trains.push({
            id: nextTrainId++,
            line: line,
            direction: -1,
            currentSegment: line.stations.length - 2,
            progress: 0,
            state: "dwell",
            dwellStart: now,
            travelTime: 0,
            onboard: []
          });
        } else {
          // For loop lines, spawn two trains going in opposite directions.
          let idx1 = 0;
          let idx2 = Math.floor((line.stations.length - 1) / 2);
          line.trains.push({
            id: nextTrainId++,
            line: line,
            direction: 1,
            currentSegment: idx1,
            progress: 0,
            state: "dwell",
            dwellStart: now,
            travelTime: 0,
            onboard: []
          });
          line.trains.push({
            id: nextTrainId++,
            line: line,
            direction: -1, // opposite direction
            currentSegment: idx2,
            progress: 0,
            state: "dwell",
            dwellStart: now,
            travelTime: 0,
            onboard: []
          });
        }
      }

      function updateTrains(now){
        for(let line of metroLines){
          for(let train of line.trains){
            let segIndex = train.currentSegment;
            let from = line.stations[segIndex];
            let to = line.stations[segIndex+1];
            let segLength = distance(from.x, from.y, to.x, to.y);
            if(train.state === "dwell"){
              if(now - train.dwellStart >= dwellTime){
                train.travelTime = computeTravelTime(segLength);
                train.state = "moving";
                train.departureTime = now;
              }
            } else if(train.state === "moving"){
              let elapsed = now - train.departureTime;
              let p = elapsed / train.travelTime;
              let ease = 0.5 - 0.5 * Math.cos(Math.PI * Math.min(p,1));
              train.progress = ease;
              if(p >= 1){
                // Arrived at destination station.
                if(line.isLoop){
                  train.currentSegment = (train.currentSegment + train.direction) % (line.stations.length - 1);
                  if(train.currentSegment < 0) train.currentSegment += (line.stations.length - 1);
                } else {
                  if(train.direction === 1 && train.currentSegment >= line.stations.length - 2){
                    train.direction = -1;
                  } else if(train.direction === -1 && train.currentSegment <= 0){
                    train.direction = 1;
                  }
                  train.currentSegment += train.direction;
                }
                train.state = "dwell";
                train.dwellStart = now;
                train.progress = 0;
              }
            }
          }
        }
      }

      // ========= COMMUTER SIMULATION =========
      // The network graph is built from each line’s consecutive stations.
      function buildGraph(){
        let graph = {};
        for(let s of stations) graph[s.id] = [];
        for(let line of metroLines){
          for(let i = 0; i < line.stations.length - 1; i++){
            let a = line.stations[i], b = line.stations[i+1];
            graph[a.id].push({ station: b, line: line });
            graph[b.id].push({ station: a, line: line });
          }
        }
        return graph;
      }

      // BFS to compute a route from start to goal. Returns an array of segments.
      function computeRoute(start, goal){
        let graph = buildGraph();
        let queue = [ start ];
        let visited = {};
        visited[start.id] = null;
        while(queue.length){
          let current = queue.shift();
          if(current === goal) break;
          for(let edge of graph[current.id]){
            if(!(edge.station.id in visited)){
              visited[edge.station.id] = { from: current, line: edge.line };
              queue.push(edge.station);
            }
          }
        }
        if(!(goal.id in visited)) return null;
        let route = [];
        let cur = goal;
        while(cur !== start){
          let info = visited[cur.id];
          route.unshift({ from: info.from, to: cur, line: info.line });
          cur = info.from;
        }
        return route;
      }

      // Spawn a commuter at a random station with a random destination.
      function spawnCommuter(){
        if(stations.length < 2) return;
        let start = stations[Math.floor(Math.random()*stations.length)];
        let dest;
        do {
          dest = stations[Math.floor(Math.random()*stations.length)];
        } while(dest === start);
        let route = computeRoute(start, dest);
        let commuter = {
          id: nextCommuterId++,
          currentStation: start,
          destinationStation: dest,
          state: "waiting",
          route: route
        };
        commuters.push(commuter);
      }

      function updateCommuters(now){
        for(let commuter of commuters){
          if(commuter.state === "waiting"){
            if(commuter.currentStation === commuter.destinationStation) continue;
            if(!commuter.route) commuter.route = computeRoute(commuter.currentStation, commuter.destinationStation);
            if(commuter.route && commuter.route.length > 0){
              let seg = commuter.route[0];
              // Look for a train on the needed line that is dwelling at the commuter’s station.
              let candidate = seg.line.trains.find(train => {
                if(train.state !== "dwell") return false;
                let posStation = (train.direction === 1) ? seg.line.stations[train.currentSegment] : seg.line.stations[train.currentSegment+1];
                return posStation === commuter.currentStation;
              });
              if(candidate){
                commuter.state = "inTrain";
                candidate.onboard = candidate.onboard || [];
                candidate.onboard.push(commuter);
              }
            }
          }
        }
        // When a train completes a segment, disembark onboard commuters whose next segment has been reached.
        for(let line of metroLines){
          for(let train of line.trains){
            if(train.state === "dwell"){
              let currentStation = (train.direction === 1) ? line.stations[train.currentSegment] : line.stations[train.currentSegment+1];
              if(train.onboard && train.onboard.length){
                train.onboard.forEach(commuter => {
                  if(commuter.route && commuter.route.length > 0 && commuter.route[0].to === currentStation){
                    commuter.currentStation = currentStation;
                    commuter.state = "waiting";
                    commuter.route.shift();
                  }
                });
                train.onboard = [];
              }
            }
          }
        }
        commuters = commuters.filter(c => c.currentStation !== c.destinationStation);
      }

      // ========= DRAWING =========
      function drawStations(){
        for(let s of stations){
          ctx.beginPath();
          ctx.arc(s.x, s.y, stationRadius, 0, 2 * Math.PI);
          ctx.fillStyle = "#FFF";
          ctx.fill();
          ctx.strokeStyle = "#000";
          ctx.stroke();
          ctx.fillStyle = "#000";
          ctx.font = "12px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(s.id, s.x, s.y);
        }
      }

      function drawMetroLines(){
        for(let line of metroLines){
          ctx.beginPath();
          ctx.lineWidth = 4;
          ctx.strokeStyle = line.color;
          for(let i = 0; i < line.stations.length; i++){
            let s = line.stations[i];
            if(i === 0) ctx.moveTo(s.x, s.y);
            else ctx.lineTo(s.x, s.y);
          }
          ctx.stroke();
          ctx.lineWidth = 2;
        }
      }

      // Draw the line currently being drawn or edited.
      function drawActiveLine(){
        if(activeLine){
          ctx.beginPath();
          ctx.lineWidth = 4;
          ctx.strokeStyle = activeLine.color;
          for(let i = 0; i < activeLine.stations.length; i++){
            let s = activeLine.stations[i];
            if(i === 0) ctx.moveTo(s.x, s.y);
            else ctx.lineTo(s.x, s.y);
          }
          if(activeLine.stations.length > 0){
            ctx.lineTo(currentMousePos.x, currentMousePos.y);
          }
          ctx.stroke();
          ctx.lineWidth = 2;
        }
      }

      function drawTrains(){
        for(let line of metroLines){
          for(let train of line.trains){
            let seg = train.currentSegment;
            let from = line.stations[seg];
            let to = line.stations[seg+1];
            let x = from.x + (to.x - from.x) * train.progress;
            let y = from.y + (to.y - from.y) * train.progress;
            let angle = Math.atan2(to.y - from.y, to.x - from.x);
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.fillStyle = "green";
            ctx.fillRect(-trainWidth/2, -trainHeight/2, trainWidth, trainHeight);
            ctx.fillStyle = "white";
            ctx.font = "10px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(train.id, 0, 0);
            // If passengers are onboard, display their destination letters above the train.
            if(train.onboard && train.onboard.length > 0){
              let dests = train.onboard.map(c => c.destinationStation.id).join(",");
              ctx.fillStyle = "white";
              ctx.font = "10px Arial";
              ctx.fillText(dests, 0, -trainHeight);
            }
            ctx.restore();
          }
        }
      }

      function drawCommuters(){
        for(let commuter of commuters){
          // Draw waiting commuters as small blue circles with their target shown next to them.
          if(commuter.state === "waiting"){
            let s = commuter.currentStation;
            ctx.beginPath();
            ctx.arc(s.x, s.y, 5, 0, 2 * Math.PI);
            ctx.fillStyle = "blue";
            ctx.fill();
            ctx.fillStyle = "white";
            ctx.font = "10px Arial";
            ctx.textAlign = "left";
            ctx.textBaseline = "middle";
            ctx.fillText(commuter.destinationStation.id, s.x + 8, s.y);
          }
        }
      }

      function draw(){
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawMetroLines();
        drawActiveLine();
        drawStations();
        drawTrains();
        drawCommuters();
      }

      // ========= UPDATE LOOP =========
      function update(now){
        updateTrains(now);
        updateCommuters(now);
        draw();
        requestAnimationFrame(update);
      }

      // ========= INITIALIZATION =========
      initStations();
      setInterval(spawnCommuter, commuterSpawnInterval);
      requestAnimationFrame(update);
    })();
  </script>
</body>
</html>
