<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Metro System Designer & Simulator</title>
  <style>
    body { font-family: sans-serif; }
    canvas { border: 1px solid #000; background-color: #f0f0f0; }
    #controls { margin-bottom: 10px; }
    #controls > * { margin-right: 10px; }
  </style>
</head>
<body>
  <h1>Metro System Designer & Simulator</h1>
  <div id="controls">
    <label for="lineColorPicker">Line Color:</label>
    <input type="color" id="lineColorPicker" value="#ff0000">
    <button id="newLineButton">New Line</button>
    <button id="deleteLineButton">Delete Line</button>
  </div>
  <p>
    <strong>How to use:</strong> Click “New Line” then click on a station to begin a new line. As you drag the mouse, if you pass close to another station the line “snaps” to that station (adding it to the route). Drag back over the previous station to remove the last stop. Drag back to the starting station (when there are at least three stops) to complete a loop. You can also modify an existing line by clicking on one of its segments – the selected line will be highlighted. When finished drawing (double–click), the line is saved and two trains are spawned (one per direction, or circulating if a loop). Commuters spawn at random stations with a destination; they board trains (only when the train is dwelling) and ride to their destination.
  </p>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <script>
    (function(){
      // ========= CONFIGURATION =========
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const stationRadius = 15;
      const snapThreshold = 20; // distance within which a station snaps
      const trainWidth = 30, trainHeight = 15;
      const dwellTime = 2000;      // ms dwell time at station
      const acceleration = 0.001;  // px/(ms^2)
      const maxSpeed = 0.3;        // px/ms
      const commuterSpawnInterval = 3000; // ms
      const stationCount = 10; // total stations

      // ========= DATA STRUCTURES =========
      let stations = [];      // list of station objects { id, x, y }
      let metroLines = [];    // list of lines; each: { id, color, stations:[...], trains: [] }
      // When drawing or editing a line, activeLine holds the current line being built.
      // It has an extra property "editingMode": either "new" or "edit".
      let activeLine = null;

      // Commuters: each { id, currentStation, destinationStation, state:"waiting"|"inTrain", route:[{line, from, to}] }
      let commuters = [];
      // Unique id counters
      let nextLineId = 1, nextTrainId = 1, nextCommuterId = 1;

      // ========= UI ELEMENTS =========
      const lineColorPicker = document.getElementById('lineColorPicker');
      const newLineButton = document.getElementById('newLineButton');
      const deleteLineButton = document.getElementById('deleteLineButton');

      newLineButton.addEventListener('click', () => {
        // Start drawing a new line if not already drawing one.
        if(activeLine) return;
        activeLine = {
          id: nextLineId++,
          color: lineColorPicker.value,
          stations: [],
          trains: [],
          editingMode: "new"
        };
      });

      deleteLineButton.addEventListener('click', () => {
        // Delete active line (if in edit mode)
        if(activeLine && activeLine.editingMode === "edit"){
          metroLines = metroLines.filter(l => l !== activeLine);
          activeLine = null;
        }
      });

      // ========= INITIALIZE STATIONS =========
      function initStations(){
        const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        for(let i=0; i<stationCount; i++){
          let s = {
            id: letters[i],
            x: Math.random()*(canvas.width-40) + 20,
            y: Math.random()*(canvas.height-40) + 20
          };
          stations.push(s);
        }
      }

      // ========= HELPER FUNCTIONS =========
      function distance(x1,y1,x2,y2){
        return Math.hypot(x2-x1, y2-y1);
      }

      // Given a point, return a station if within stationRadius
      function getStationAt(x,y){
        for(let s of stations){
          if(distance(x,y,s.x,s.y) < stationRadius) return s;
        }
        return null;
      }

      // Given a point, check if near any station (within snapThreshold)
      function getSnappedStation(x,y){
        for(let s of stations){
          if(distance(x,y,s.x,s.y) < snapThreshold) return s;
        }
        return null;
      }

      // Check if point (x,y) is near any segment of any metro line.
      // Returns {line, segmentIndex} if found.
      function getLineSegmentAt(x,y){
        for(let line of metroLines){
          for(let i=0; i<line.stations.length-1; i++){
            let a = line.stations[i], b = line.stations[i+1];
            let d = distanceToSegment(x,y, a.x, a.y, b.x, b.y);
            if(d < 5) return { line: line, segmentIndex: i };
          }
        }
        return null;
      }

      // Distance from point (px,py) to segment (x1,y1)-(x2,y2)
      function distanceToSegment(px,py,x1,y1,x2,y2){
        const l2 = Math.pow(distance(x1,y1,x2,y2),2);
        if(l2 === 0) return distance(px,py,x1,y1);
        let t = ((px - x1)*(x2-x1) + (py-y1)*(y2-y1)) / l2;
        t = Math.max(0, Math.min(1, t));
        return distance(px,py, x1 + t*(x2-x1), y1 + t*(y2-y1));
      }

      // Compute travel time along a segment of length d, using acceleration and deceleration.
      function computeTravelTime(d){
        const t_acc = maxSpeed/acceleration;
        const d_acc = 0.5 * acceleration * t_acc*t_acc;
        if(d >= 2*d_acc){
          let t_cruise = (d - 2*d_acc)/maxSpeed;
          return t_acc + t_cruise + t_acc;
        } else {
          return 2 * Math.sqrt(d/acceleration);
        }
      }

      // ========= LINE DRAWING / EDITING =========
      let isDragging = false;
      let currentMousePos = { x:0, y:0 };

      canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        let x = e.clientX - rect.left;
        let y = e.clientY - rect.top;
        // If not currently drawing/editing a line, try to select an existing line by clicking on a segment.
        if(!activeLine){
          let seg = getLineSegmentAt(x,y);
          if(seg){
            activeLine = seg.line;
            activeLine.editingMode = "edit";
          }
        } else {
          // If we are drawing a new line and it has no stations yet, try to snap to a station.
          if(activeLine.stations.length === 0){
            let s = getStationAt(x,y);
            if(s) activeLine.stations.push(s);
          }
        }
        isDragging = true;
      });

      canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        currentMousePos.x = e.clientX - rect.left;
        currentMousePos.y = e.clientY - rect.top;
        if(activeLine && isDragging){
          // If already have at least one station, try to snap to a station.
          let snapped = getSnappedStation(currentMousePos.x, currentMousePos.y);
          if(snapped){
            let stationsArr = activeLine.stations;
            let len = stationsArr.length;
            // If the snapped station is the same as the last one, do nothing.
            if(len > 0 && snapped === stationsArr[len-1]){
              // no change
            }
            // If snapping to the second-to-last station, remove the last station (undo).
            else if(len>=2 && snapped === stationsArr[len-2]){
              stationsArr.pop();
            }
            // Otherwise, if the snapped station isn’t already the last one, add it.
            else if(len === 0 || snapped !== stationsArr[len-1]){
              activeLine.stations.push(snapped);
            }
          }
        }
      });

      canvas.addEventListener('mouseup', (e) => {
        isDragging = false;
      });

      // On double click, finish the line drawing/editing.
      canvas.addEventListener('dblclick', (e) => {
        if(activeLine){
          // Only accept lines with at least two stops.
          if(activeLine.stations.length >= 2){
            // If the last station equals the first (and at least 3 stations), mark as loop.
            let isLoop = false;
            if(activeLine.stations[0] === activeLine.stations[activeLine.stations.length-1] &&
               activeLine.stations.length >= 3) {
              isLoop = true;
            }
            activeLine.isLoop = isLoop;
            // If this is a new line, add it to the system.
            if(activeLine.editingMode === "new"){
              metroLines.push(activeLine);
              spawnDefaultTrains(activeLine);
            }
            // For editing mode, you may want to respawn trains if needed (for simplicity, we leave existing trains).
          }
          activeLine = null;
        }
      });

      // ========= TRAIN SIMULATION =========
      // Each train: { id, line, direction (1 or -1), currentSegment (index), progress (0..1),
      // state: "dwell" or "moving", dwellStart, departureTime, travelTime, onboard: [] }
      function spawnDefaultTrains(line){
        line.trains = [];
        let now = performance.now();
        // For non-loop lines: spawn one train at each end.
        if(!line.isLoop){
          // Train going forward from first segment:
          line.trains.push({
            id: nextTrainId++,
            line: line,
            direction: 1,
            currentSegment: 0, // moving from stations[0] to stations[1]
            progress: 0,
            state: "dwell",
            dwellStart: now,
            travelTime: 0,
            onboard: []
          });
          // Train going backward from last segment:
          line.trains.push({
            id: nextTrainId++,
            line: line,
            direction: -1,
            currentSegment: line.stations.length - 2, // from last to second last
            progress: 0,
            state: "dwell",
            dwellStart: now,
            travelTime: 0,
            onboard: []
          });
        } else {
          // For loops, spawn two trains roughly half–loop apart.
          let idx1 = 0;
          let idx2 = Math.floor((line.stations.length - 1)/2);
          line.trains.push({
            id: nextTrainId++,
            line: line,
            direction: 1,
            currentSegment: idx1,
            progress: 0,
            state: "dwell",
            dwellStart: now,
            travelTime: 0,
            onboard: []
          });
          line.trains.push({
            id: nextTrainId++,
            line: line,
            direction: 1,
            currentSegment: idx2,
            progress: 0,
            state: "dwell",
            dwellStart: now,
            travelTime: 0,
            onboard: []
          });
        }
      }

      function updateTrains(now){
        for(let line of metroLines){
          for(let train of line.trains){
            // Get the current segment endpoints:
            let segIndex = train.currentSegment;
            let from = line.stations[segIndex];
            let to = line.stations[segIndex+1];
            let segLength = distance(from.x, from.y, to.x, to.y);
            if(train.state === "dwell"){
              if(now - train.dwellStart >= dwellTime){
                // Begin moving along segment. Compute travel time.
                train.travelTime = computeTravelTime(segLength);
                train.state = "moving";
                train.departureTime = now;
              }
            } else if(train.state === "moving"){
              let elapsed = now - train.departureTime;
              let p = elapsed / train.travelTime;
              // Use cosine ease in/out
              let ease = 0.5 - 0.5 * Math.cos(Math.PI * Math.min(p,1));
              train.progress = ease;
              if(p >= 1){
                // Arrived at destination station of segment.
                // (In a complete simulation, we would disembark/board commuters here.)
                // Update currentSegment depending on direction and whether line is loop.
                if(line.isLoop){
                  train.currentSegment = (train.currentSegment + train.direction) % (line.stations.length-1);
                  if(train.currentSegment < 0) train.currentSegment += (line.stations.length-1);
                } else {
                  // For non-loop lines, reverse direction at endpoints.
                  if(train.direction === 1 && train.currentSegment >= line.stations.length - 2){
                    train.direction = -1;
                  } else if(train.direction === -1 && train.currentSegment <= 0){
                    train.direction = 1;
                  } else {
                    // continue normally
                  }
                  train.currentSegment += train.direction;
                }
                // Set state to dwell at the arrived station.
                train.state = "dwell";
                train.dwellStart = now;
                train.progress = 0;
              }
            }
          }
        }
      }

      // ========= COMMUTER SIMULATION =========
      // For simplicity, commuters use the network (built from all metro line segments) to compute a route.
      // The network is built by taking each metro line and adding an edge for each consecutive station.
      function buildGraph(){
        let graph = {}; // station id -> list of { station, line }
        for(let s of stations) graph[s.id] = [];
        for(let line of metroLines){
          for(let i=0; i<line.stations.length-1; i++){
            let a = line.stations[i], b = line.stations[i+1];
            graph[a.id].push({ station: b, line: line });
            graph[b.id].push({ station: a, line: line });
          }
        }
        return graph;
      }

      // BFS to compute a route from start to goal.
      // Returns a route: an array of segments: { from, to, line }
      function computeRoute(start, goal){
        let graph = buildGraph();
        let queue = [ start ];
        let visited = {};
        visited[start.id] = null;
        while(queue.length){
          let current = queue.shift();
          if(current === goal) break;
          for(let edge of graph[current.id]){
            if(!(edge.station.id in visited)){
              visited[edge.station.id] = { from: current, line: edge.line };
              queue.push(edge.station);
            }
          }
        }
        if(!(goal.id in visited)) return null;
        // Reconstruct route backwards.
        let route = [];
        let cur = goal;
        while(cur !== start){
          let info = visited[cur.id];
          route.unshift({ from: info.from, to: cur, line: info.line });
          cur = info.from;
        }
        return route;
      }

      // Spawn a commuter at a random station with a random destination.
      function spawnCommuter(){
        if(stations.length < 2) return;
        let start = stations[Math.floor(Math.random()*stations.length)];
        let dest;
        do {
          dest = stations[Math.floor(Math.random()*stations.length)];
        } while(dest===start);
        let route = computeRoute(start, dest);
        let commuter = {
          id: nextCommuterId++,
          currentStation: start,
          destinationStation: dest,
          state: "waiting",  // or "inTrain"
          route: route // may be null if no route exists
        };
        commuters.push(commuter);
      }

      // For each waiting commuter at a station, if a train on the needed line is dwelling at that station, board it.
      function updateCommuters(now){
        for(let commuter of commuters){
          if(commuter.state === "waiting"){
            if(commuter.currentStation === commuter.destinationStation) continue;
            if(!commuter.route) commuter.route = computeRoute(commuter.currentStation, commuter.destinationStation);
            if(commuter.route && commuter.route.length > 0){
              let seg = commuter.route[0]; // segment to travel next
              // Look for a train on seg.line that is dwelling at commuter.currentStation and is about to go toward seg.to.
              let candidate = seg.line.trains.find(train => {
                if(train.state !== "dwell") return false;
                // Determine the station at which the train is dwelling.
                let posStation = (train.direction === 1) ? seg.line.stations[train.currentSegment] : seg.line.stations[train.currentSegment+1];
                return posStation === commuter.currentStation;
              });
              if(candidate){
                // Board commuter (for simplicity, remove from waiting and assume they'll disembark on arrival).
                commuter.state = "inTrain";
                // When the train next reaches the next station, remove this segment from commuter.route.
                candidate.onboard = candidate.onboard || [];
                candidate.onboard.push(commuter);
              }
            }
          }
        }
        // When a train completes a segment (in updateTrains, when switching to dwell), disembark onboard commuters whose next target is that station.
        for(let line of metroLines){
          for(let train of line.trains){
            if(train.state === "dwell"){
              // Determine current station at which the train is dwelling.
              let currentStation = (train.direction === 1) ? line.stations[train.currentSegment] : line.stations[train.currentSegment+1];
              if(train.onboard && train.onboard.length){
                train.onboard.forEach(commuter => {
                  // If the commuter's next route segment matches arriving at currentStation, disembark.
                  if(commuter.route && commuter.route.length>0 && commuter.route[0].to === currentStation){
                    commuter.currentStation = currentStation;
                    commuter.state = "waiting";
                    // Remove the traveled segment.
                    commuter.route.shift();
                    // If reached destination, they will be removed later.
                  }
                });
                // Clear onboard list.
                train.onboard = [];
              }
            }
          }
        }
        // Remove commuters that have reached destination.
        commuters = commuters.filter(c => c.currentStation !== c.destinationStation);
      }

      // ========= DRAWING =========
      function drawStations(){
        for(let s of stations){
          ctx.beginPath();
          ctx.arc(s.x, s.y, stationRadius, 0, 2*Math.PI);
          ctx.fillStyle = "#FFF";
          ctx.fill();
          ctx.strokeStyle = "#000";
          ctx.stroke();
          ctx.fillStyle = "#000";
          ctx.font = "12px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(s.id, s.x, s.y);
        }
      }

      function drawMetroLines(){
        for(let line of metroLines){
          ctx.beginPath();
          ctx.lineWidth = 4;
          ctx.strokeStyle = line.color;
          for(let i=0; i<line.stations.length; i++){
            let s = line.stations[i];
            if(i===0) ctx.moveTo(s.x, s.y);
            else ctx.lineTo(s.x, s.y);
          }
          ctx.stroke();
          ctx.lineWidth = 2;
        }
      }

      // Draw the active (being drawn or edited) line
      function drawActiveLine(){
        if(activeLine){
          ctx.beginPath();
          ctx.lineWidth = 4;
          ctx.strokeStyle = activeLine.color;
          for(let i=0; i<activeLine.stations.length; i++){
            let s = activeLine.stations[i];
            if(i===0) ctx.moveTo(s.x, s.y);
            else ctx.lineTo(s.x, s.y);
          }
          // Also draw a temporary line from the last snapped station to current mouse position.
          if(activeLine.stations.length > 0){
            ctx.lineTo(currentMousePos.x, currentMousePos.y);
          }
          ctx.stroke();
          ctx.lineWidth = 2;
        }
      }

      // Draw trains on all metro lines
      function drawTrains(){
        for(let line of metroLines){
          for(let train of line.trains){
            // Determine train position along current segment.
            let seg = train.currentSegment;
            let from = line.stations[seg];
            let to = line.stations[seg+1];
            let x = from.x + (to.x - from.x)*train.progress;
            let y = from.y + (to.y - from.y)*train.progress;
            // Compute orientation angle.
            let angle = Math.atan2(to.y-from.y, to.x-from.x);
            ctx.save();
            ctx.translate(x,y);
            ctx.rotate(angle);
            ctx.fillStyle = "green";
            ctx.fillRect(-trainWidth/2, -trainHeight/2, trainWidth, trainHeight);
            ctx.fillStyle = "white";
            ctx.font = "10px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(train.id, 0, 0);
            ctx.restore();
          }
        }
      }

      // Draw waiting commuters as small blue circles at their station.
      function drawCommuters(){
        for(let commuter of commuters){
          // Only draw those waiting.
          if(commuter.state === "waiting"){
            let s = commuter.currentStation;
            ctx.beginPath();
            ctx.arc(s.x, s.y, 5, 0, 2*Math.PI);
            ctx.fillStyle = "blue";
            ctx.fill();
            ctx.fillStyle = "white";
            ctx.font = "10px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(commuter.destinationStation.id, s.x, s.y);
          }
        }
      }

      function draw(){
        ctx.clearRect(0,0,canvas.width, canvas.height);
        drawMetroLines();
        drawActiveLine();
        drawStations();
        drawTrains();
        drawCommuters();
      }

      // ========= UPDATE LOOP =========
      function update(now){
        updateTrains(now);
        updateCommuters(now);
        draw();
        requestAnimationFrame(update);
      }

      // ========= INITIALIZATION =========
      initStations();
      // Start spawning commuters periodically.
      setInterval(spawnCommuter, commuterSpawnInterval);
      requestAnimationFrame(update);
    })();
  </script>
</body>
</html>
