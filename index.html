<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Metro System Designer & Simulator</title>
  <style>
    body { font-family: sans-serif; margin:0; padding:0; }
    canvas { border: 1px solid #000; background-color: #f0f0f0; display: block; margin: 0 auto; }
    #controls { margin: 10px; }
    #controls > * { margin-right: 10px; }
    #counter { position: absolute; top: 10px; right: 10px; font-size: 18px; font-weight: bold; background: rgba(255,255,255,0.8); padding: 5px 10px; border: 1px solid #000; }
    #trainPopup {
      position: absolute;
      background: rgba(255,255,255,0.95);
      border: 1px solid #000;
      padding: 5px;
      display: none;
      pointer-events: none;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div id="controls">
    <label for="lineColorDropdown">Line Color:</label>
    <select id="lineColorDropdown">
      <option value="#ff0000" selected>Red</option>
      <option value="#0000ff">Blue</option>
      <option value="#00ff00">Green</option>
      <option value="#ffff00">Yellow</option>
      <option value="#800080">Purple</option>
      <option value="#ffa500">Orange</option>
      <option value="#00ffff">Cyan</option>
      <option value="#ff00ff">Magenta</option>
      <option value="#8b4513">Brown</option>
      <option value="#000000">Black</option>
    </select>
    <button id="newLineButton">New Line</button>
    <button id="deleteLineButton">Delete Line</button>
  </div>
  <div id="counter">Arrived: 0</div>
  <div id="trainPopup"></div>
  <p style="margin:10px;">
    <strong>How to use:</strong><br>
    • Click “New Line” then click on a station to begin drawing a new metro line. As you drag, if you pass near another station the route “snaps” to it. (A station already in the route won’t be added again—except if it’s the starting station, which will complete a loop if you have at least two stops.)<br>
    • In modify mode (by clicking an existing segment) drag from the pivot point. Dragging over one of the pivot’s endpoints will remove that stop (allowed even for loop lines or the last station in a non‑loop) as long as the resulting route still has at least 2 stops (or 3 for loops); dragging over any other station inserts it between.<br>
    • “Delete Line” removes every line whose color matches the current dropdown selection.<br>
    • Waiting commuters are drawn as small blue circles with a bold red “→ X” label showing their destination. Hovering over one highlights its planned route.<br>
    • Passengers board trains—only the train heading toward the next station in their computed route is accepted. When that train arrives at the station (whether a transfer or final destination) the passenger disembarks immediately (with a “tada” burst and the global counter incrementing).<br>
    • You can mouse over any train to see a popup list of its onboard passengers.<br>
    • New stations will be added gradually (up to 26 total).<br>
    • The background shows a city-map–style grid and hints of city blocks.
  </p>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <script>
    (function(){
      // ========= CONFIGURATION =========
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const stationRadius = 15;
      const snapThreshold = 20;
      const trainWidth = 30, trainHeight = 15;
      const dwellTime = 2000;
      const acceleration = 0.0005;
      const maxSpeed = 0.05;
      const commuterSpawnInterval = 3000;
      const initialStationCount = 3;
      const maxStationCount = 26;
      const minStationDist = 80;
      const stationAddInterval = 15000; // add new station every 15 seconds

      // ========= GLOBAL STATE =========
      let stations = [];  // each: { id, x, y }
      let metroLines = []; // each: { id, color, stations: [...], trains: [], isLoop }
      // activeLine is used for drawing or modifying a line.
      // In modify mode, store: editingMode = "modify", modifySegmentIndex, originalStations, modifyCursor, modifyCandidate.
      let activeLine = null;
      // Commuters: { id, currentStation, destinationStation, state:"waiting"|"inTrain", route:[{line, from, to}] }
      let commuters = [];
      let nextLineId = 1, nextTrainId = 1, nextCommuterId = 1;
      let arrivedCount = 0;
      let arrivalEffects = []; // each: { x, y, startTime }
      let hoveredCommuter = null;
      let hoveredTrain = null;
      const trainPopup = document.getElementById('trainPopup');

      // ========= UI ELEMENTS =========
      const lineColorDropdown = document.getElementById('lineColorDropdown');
      const newLineButton = document.getElementById('newLineButton');
      const deleteLineButton = document.getElementById('deleteLineButton');
      const counterDiv = document.getElementById('counter');

      newLineButton.addEventListener('click', () => {
        if(activeLine) return;
        activeLine = {
          id: nextLineId++,
          color: lineColorDropdown.value,
          stations: [],
          trains: [],
          editingMode: "new"
        };
      });
      deleteLineButton.addEventListener('click', () => {
        metroLines = metroLines.filter(line => line.color !== lineColorDropdown.value);
      });

      // ========= STATION MANAGEMENT =========
      const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      function initStations(){
        for(let i = 0; i < initialStationCount; i++){
          addNewStation();
        }
      }
      function addNewStation(){
        if(stations.length >= maxStationCount) return;
        let newLetter = letters[stations.length];
        let valid = false, s, attempts = 0;
        while(!valid && attempts < 1000){
          s = {
            id: newLetter,
            x: Math.random()*(canvas.width-80) + 40,
            y: Math.random()*(canvas.height-80) + 40
          };
          valid = stations.every(st => distance(st.x, st.y, s.x, s.y) >= minStationDist);
          attempts++;
        }
        if(valid) stations.push(s);
      }
      setInterval(addNewStation, stationAddInterval);

      // ========= HELPER FUNCTIONS =========
      function distance(x1, y1, x2, y2){
        return Math.hypot(x2-x1, y2-y1);
      }
      function getStationAt(x, y){
        for(let s of stations){
          if(distance(x, y, s.x, s.y) < stationRadius) return s;
        }
        return null;
      }
      function getSnappedStation(x, y){
        for(let s of stations){
          if(distance(x, y, s.x, s.y) < snapThreshold) return s;
        }
        return null;
      }
      function getLineSegmentAt(x, y){
        for(let line of metroLines){
          for(let i = 0; i < line.stations.length - 1; i++){
            let a = line.stations[i], b = line.stations[i+1];
            let d = distanceToSegment(x, y, a.x, a.y, b.x, b.y);
            if(d < 5) return { line: line, segmentIndex: i };
          }
        }
        return null;
      }
      function distanceToSegment(px, py, x1, y1, x2, y2){
        const l2 = Math.pow(distance(x1, y1, x2, y2), 2);
        if(l2 === 0) return distance(px, py, x1, y1);
        let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2;
        t = Math.max(0, Math.min(1, t));
        return distance(px, py, x1 + t*(x2-x1), y1 + t*(y2-y1));
      }
      function computeTravelTime(d){
        const t_acc = maxSpeed / acceleration;
        const d_acc = 0.5 * acceleration * t_acc * t_acc;
        if(d >= 2 * d_acc){
          let t_cruise = (d - 2 * d_acc) / maxSpeed;
          return t_acc + t_cruise + t_acc;
        } else {
          return 2 * Math.sqrt(d / acceleration);
        }
      }

      // ========= BACKGROUND DRAWING =========
      function drawBackground(){
        // Draw a subtle grid
        let gridSpacing = 50;
        ctx.save();
        ctx.strokeStyle = "#e0e0e0";
        ctx.lineWidth = 1;
        for(let x = 0; x <= canvas.width; x += gridSpacing){
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height);
          ctx.stroke();
        }
        for(let y = 0; y <= canvas.height; y += gridSpacing){
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width, y);
          ctx.stroke();
        }
        // Draw a few random city block shapes
        for(let i = 0; i < 5; i++){
          let bx = Math.random() * canvas.width;
          let by = Math.random() * canvas.height;
          let bWidth = 40 + Math.random() * 60;
          let bHeight = 40 + Math.random() * 60;
          ctx.fillStyle = "rgba(200,200,200,0.3)";
          ctx.fillRect(bx, by, bWidth, bHeight);
        }
        ctx.restore();
      }

      // ========= LINE DRAWING / EDITING =========
      let isDragging = false;
      let currentMousePos = { x: 0, y: 0 };

      canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        let x = e.clientX - rect.left;
        let y = e.clientY - rect.top;
        if(!activeLine){
          let segInfo = getLineSegmentAt(x, y);
          if(segInfo){
            activeLine = segInfo.line;
            activeLine.editingMode = "modify";
            activeLine.modifySegmentIndex = segInfo.segmentIndex;
            activeLine.originalStations = activeLine.stations.slice();
            activeLine.modifyCursor = { x, y };
            activeLine.modifyCandidate = null;
          }
        } else if(activeLine.editingMode === "new"){
          if(activeLine.stations.length === 0){
            let s = getStationAt(x, y);
            if(s) activeLine.stations.push(s);
          }
        }
        isDragging = true;
      });
      canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        currentMousePos.x = e.clientX - rect.left;
        currentMousePos.y = e.clientY - rect.top;
        if(activeLine && isDragging){
          if(activeLine.editingMode === "new"){
            let snapped = getSnappedStation(currentMousePos.x, currentMousePos.y);
            if(snapped){
              let arr = activeLine.stations;
              // Allow loop completion: if snapped equals the first station and at least 2 stops exist, add it
              if(snapped.id === arr[0].id && arr.length >= 2){
                if(arr[arr.length-1].id !== snapped.id) arr.push(snapped);
              } else {
                // If station already exists, allow undo only if it's immediately before the last stop.
                if(arr.length > 1 && arr[arr.length-2].id === snapped.id){
                  arr.pop();
                } else if(arr.some(s => s.id === snapped.id)){
                  // Do nothing if already exists.
                } else {
                  arr.push(snapped);
                }
              }
            }
          } else if(activeLine.editingMode === "modify"){
            let candidate = getSnappedStation(currentMousePos.x, currentMousePos.y);
            if(candidate){
              activeLine.modifyCursor = { x: candidate.x, y: candidate.y };
              activeLine.modifyCandidate = candidate;
            } else {
              activeLine.modifyCursor = { x: currentMousePos.x, y: currentMousePos.y };
              activeLine.modifyCandidate = null;
            }
          }
        }
        // Hover detection for waiting commuters.
        hoveredCommuter = null;
        let waitingByStation = {};
        for(let commuter of commuters){
          if(commuter.state === "waiting"){
            let id = commuter.currentStation.id;
            if(!waitingByStation[id]) waitingByStation[id] = [];
            waitingByStation[id].push(commuter);
          }
        }
        for(let stationId in waitingByStation){
          let group = waitingByStation[stationId];
          group.sort((a,b) => a.id - b.id);
          let station = stations.find(s => s.id === stationId);
          let spacing = 12;
          for(let i = 0; i < group.length; i++){
            let offset = (i - (group.length - 1)/2) * spacing;
            let pos = { x: station.x + offset, y: station.y };
            if(distance(currentMousePos.x, currentMousePos.y, pos.x, pos.y) < 8){
              hoveredCommuter = group[i];
              break;
            }
          }
          if(hoveredCommuter) break;
        }
      });
      canvas.addEventListener('mouseup', (e) => {
        isDragging = false;
        if(activeLine){
          if(activeLine.editingMode === "modify"){
            let idx = activeLine.modifySegmentIndex;
            let X = activeLine.originalStations[idx];
            let Y = activeLine.originalStations[idx+1];
            // Allow removal if candidate equals one of the endpoints AND the route would remain valid.
            let minStations = activeLine.isLoop ? 3 : 2;
            if(activeLine.modifyCandidate){
              if((activeLine.modifyCandidate.id === X.id || activeLine.modifyCandidate.id === Y.id) && activeLine.originalStations.length > minStations){
                activeLine.stations = activeLine.originalStations.slice();
                if(activeLine.modifyCandidate.id === X.id){
                  activeLine.stations.splice(idx, 1);
                } else {
                  activeLine.stations.splice(idx+1, 1);
                }
              } else if(activeLine.modifyCandidate.id !== X.id && activeLine.modifyCandidate.id !== Y.id){
                if(!activeLine.originalStations.some(s => s.id === activeLine.modifyCandidate.id)){
                  activeLine.stations = activeLine.originalStations.slice();
                  activeLine.stations.splice(idx+1, 0, activeLine.modifyCandidate);
                } else {
                  activeLine.stations = activeLine.originalStations.slice();
                }
              } else {
                activeLine.stations = activeLine.originalStations.slice();
              }
            }
            activeLine.editingMode = "new";
            activeLine = null;
          }
        }
      });
      canvas.addEventListener('dblclick', (e) => {
        if(activeLine && activeLine.editingMode === "new"){
          if(activeLine.stations.length >= 2){
            // For loop lines, allow completion if first and last stations match.
            if(activeLine.stations[0].id === activeLine.stations[activeLine.stations.length-1].id && activeLine.stations.length >= 3){
              activeLine.isLoop = true;
            } else {
              activeLine.isLoop = false;
            }
            metroLines.push(activeLine);
            spawnDefaultTrains(activeLine);
          }
          activeLine = null;
        }
      });

      // ========= TRAIN SIMULATION =========
      function spawnDefaultTrains(line){
        line.trains = [];
        let now = performance.now();
        if(!line.isLoop){
          line.trains.push({
            id: nextTrainId++,
            line: line,
            direction: 1,
            currentSegment: 0,
            progress: 0,
            state: "dwell",
            dwellStart: now,
            travelTime: 0,
            onboard: []
          });
          line.trains.push({
            id: nextTrainId++,
            line: line,
            direction: -1,
            currentSegment: line.stations.length - 2,
            progress: 0,
            state: "dwell",
            dwellStart: now,
            travelTime: 0,
            onboard: []
          });
        } else {
          let idx1 = 0;
          let idx2 = Math.floor((line.stations.length - 1) / 2);
          line.trains.push({
            id: nextTrainId++,
            line: line,
            direction: 1,
            currentSegment: idx1,
            progress: 0,
            state: "dwell",
            dwellStart: now,
            travelTime: 0,
            onboard: []
          });
          line.trains.push({
            id: nextTrainId++,
            line: line,
            direction: -1,
            currentSegment: idx2,
            progress: 0,
            state: "dwell",
            dwellStart: now,
            travelTime: 0,
            onboard: []
          });
        }
      }

      function updateTrains(now){
        for(let line of metroLines){
          if(line.stations.length < 2) continue;
          for(let train of line.trains){
            if(train.currentSegment < 0) train.currentSegment = 0;
            if(train.currentSegment > line.stations.length - 2) train.currentSegment = line.stations.length - 2;
            let from, to;
            if(train.direction === 1){
              from = line.stations[train.currentSegment];
              to = line.stations[train.currentSegment+1];
            } else {
              from = line.stations[train.currentSegment+1];
              to = line.stations[train.currentSegment];
            }
            if(!from || !to) continue;
            let segLength = distance(from.x, from.y, to.x, to.y);
            if(train.state === "dwell"){
              if(now - train.dwellStart >= dwellTime){
                train.travelTime = computeTravelTime(segLength);
                train.state = "moving";
                train.departureTime = now;
              }
            } else if(train.state === "moving"){
              let elapsed = now - train.departureTime;
              let p = elapsed / train.travelTime;
              let ease = 0.5 - 0.5 * Math.cos(Math.PI * Math.min(p, 1));
              train.progress = ease;
              if(p >= 1){
                // Determine arrival station.
                let arrivalStation = (train.direction === 1) ? line.stations[train.currentSegment+1] : line.stations[train.currentSegment];
                // Disembark onboard passengers whose next segment destination equals arrivalStation.
                train.onboard.forEach(commuter => {
                  if(commuter.route && commuter.route.length > 0 && commuter.route[0].to.id === arrivalStation.id){
                    commuter.currentStation = arrivalStation;
                    commuter.route.shift();
                    if(commuter.destinationStation.id === arrivalStation.id){
                      commuter.arrived = true;
                      arrivedCount++;
                      arrivalEffects.push({ x: arrivalStation.x, y: arrivalStation.y, startTime: now });
                    } else {
                      commuter.state = "waiting";
                    }
                  }
                });
                train.onboard = [];
                if(!line.isLoop){
                  if(train.direction === 1 && train.currentSegment === line.stations.length - 2){
                    train.direction = -1;
                  } else if(train.direction === -1 && train.currentSegment === 0){
                    train.direction = 1;
                  } else {
                    train.currentSegment += train.direction;
                  }
                } else {
                  train.currentSegment = (train.currentSegment + train.direction) % (line.stations.length - 1);
                  if(train.currentSegment < 0) train.currentSegment += (line.stations.length - 1);
                }
                train.state = "dwell";
                train.dwellStart = now;
                train.progress = 0;
              }
            }
          }
        }
      }

      // ========= COMMUTER SIMULATION =========
      function buildGraph(){
        let graph = {};
        for(let s of stations) graph[s.id] = [];
        for(let line of metroLines){
          for(let i = 0; i < line.stations.length - 1; i++){
            let a = line.stations[i], b = line.stations[i+1];
            graph[a.id].push({ station: b, line: line });
            graph[b.id].push({ station: a, line: line });
          }
        }
        return graph;
      }
      function computeRoute(start, goal){
        let graph = buildGraph();
        let queue = [ start ];
        let visited = {};
        visited[start.id] = null;
        while(queue.length){
          let current = queue.shift();
          if(current === goal) break;
          for(let edge of graph[current.id]){
            if(!(edge.station.id in visited)){
              visited[edge.station.id] = { from: current, line: edge.line };
              queue.push(edge.station);
            }
          }
        }
        if(!(goal.id in visited)) return null;
        let route = [];
        let cur = goal;
        while(cur !== start){
          let info = visited[cur.id];
          route.unshift({ from: info.from, to: cur, line: info.line });
          cur = info.from;
        }
        return route;
      }
      function spawnCommuter(){
        if(stations.length < 2) return;
        let start = stations[Math.floor(Math.random()*stations.length)];
        let dest;
        do {
          dest = stations[Math.floor(Math.random()*stations.length)];
        } while(dest === start);
        let route = computeRoute(start, dest);
        let commuter = {
          id: nextCommuterId++,
          currentStation: start,
          destinationStation: dest,
          state: "waiting",
          route: route
        };
        commuters.push(commuter);
      }
      function updateCommuters(now){
        for(let commuter of commuters){
          if(commuter.state === "waiting"){
            if(commuter.currentStation.id === commuter.destinationStation.id){
              commuter.arrived = true;
              arrivedCount++;
              arrivalEffects.push({ x: commuter.currentStation.x, y: commuter.currentStation.y, startTime: now });
              continue;
            }
            commuter.route = computeRoute(commuter.currentStation, commuter.destinationStation);
            if(commuter.route && commuter.route.length > 0){
              let seg = commuter.route[0];
              let candidate = seg.line.trains.find(train => {
                if(train.state !== "dwell") return false;
                let posStation = (train.direction === 1) ? train.line.stations[train.currentSegment] : train.line.stations[train.currentSegment+1];
                if(posStation.id !== commuter.currentStation.id) return false;
                if(train.direction === 1){
                  return train.line.stations[train.currentSegment+1].id === seg.to.id;
                } else {
                  return train.line.stations[train.currentSegment].id === seg.to.id;
                }
              });
              if(candidate){
                commuter.state = "inTrain";
                candidate.onboard = candidate.onboard || [];
                candidate.onboard.push(commuter);
              }
            }
          }
        }
        commuters = commuters.filter(c => !c.arrived && c.currentStation.id !== c.destinationStation.id);
        counterDiv.textContent = "Arrived: " + arrivedCount;
      }

      // ========= DRAWING FUNCTIONS =========
      function getSegmentOffset(line, segmentIndex){
        let a = line.stations[segmentIndex], b = line.stations[segmentIndex+1];
        let sameSegmentLines = metroLines.filter(l => {
          for(let i = 0; i < l.stations.length - 1; i++){
            let p = l.stations[i], q = l.stations[i+1];
            if((p.id === a.id && q.id === b.id) || (p.id === b.id && q.id === a.id)) return true;
          }
          return false;
        });
        sameSegmentLines.sort((l1, l2) => l1.id - l2.id);
        let idx = sameSegmentLines.findIndex(l => l.id === line.id);
        let count = sameSegmentLines.length;
        let offsetDistance = 10;
        let offset = (count % 2 === 1)
          ? (idx - Math.floor(count/2)) * offsetDistance
          : (idx - count/2 + 0.5) * offsetDistance;
        return offset;
      }
      function drawStations(){
        for(let s of stations){
          ctx.beginPath();
          ctx.arc(s.x, s.y, stationRadius, 0, 2*Math.PI);
          ctx.fillStyle = "#FFF";
          ctx.fill();
          ctx.strokeStyle = "#000";
          ctx.stroke();
          ctx.fillStyle = "#000";
          ctx.font = "12px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(s.id, s.x, s.y);
        }
      }
      function drawMetroLines(){
        for(let line of metroLines){
          ctx.beginPath();
          ctx.lineWidth = 4;
          ctx.strokeStyle = line.color;
          for(let i = 0; i < line.stations.length - 1; i++){
            let s1 = line.stations[i], s2 = line.stations[i+1];
            let offset = getSegmentOffset(line, i);
            let dx = s2.x - s1.x, dy = s2.y - s1.y;
            let len = Math.sqrt(dx*dx + dy*dy);
            let offX = -dy/len * offset;
            let offY = dx/len * offset;
            let startX = s1.x + offX;
            let startY = s1.y + offY;
            let endX = s2.x + offX;
            let endY = s2.y + offY;
            if(i === 0) ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
          }
          ctx.stroke();
          ctx.lineWidth = 2;
        }
      }
      function drawActiveLine(){
        if(activeLine){
          if(activeLine.editingMode === "new"){
            ctx.beginPath();
            ctx.lineWidth = 4;
            ctx.strokeStyle = activeLine.color;
            for(let i = 0; i < activeLine.stations.length; i++){
              let s = activeLine.stations[i];
              if(i === 0) ctx.moveTo(s.x, s.y);
              else ctx.lineTo(s.x, s.y);
            }
            if(activeLine.stations.length > 0){
              ctx.lineTo(currentMousePos.x, currentMousePos.y);
            }
            ctx.stroke();
            ctx.lineWidth = 2;
          } else if(activeLine.editingMode === "modify"){
            ctx.save();
            ctx.globalAlpha = 0.3;
            ctx.beginPath();
            ctx.strokeStyle = activeLine.color;
            for(let i = 0; i < activeLine.originalStations.length; i++){
              let s = activeLine.originalStations[i];
              if(i === 0) ctx.moveTo(s.x, s.y);
              else ctx.lineTo(s.x, s.y);
            }
            ctx.stroke();
            ctx.restore();
            let tempStations = activeLine.originalStations.slice();
            let idx = activeLine.modifySegmentIndex;
            tempStations.splice(idx+1, 0, activeLine.modifyCursor);
            ctx.beginPath();
            ctx.lineWidth = 4;
            ctx.strokeStyle = activeLine.color;
            for(let i = 0; i < tempStations.length; i++){
              let p = tempStations[i];
              if(i === 0) ctx.moveTo(p.x, p.y);
              else ctx.lineTo(p.x, p.y);
            }
            ctx.stroke();
            ctx.lineWidth = 2;
          }
        }
      }
      function drawTrains(){
        hoveredTrain = null;
        for(let line of metroLines){
          for(let train of line.trains){
            let from, to;
            if(train.direction === 1){
              from = line.stations[train.currentSegment];
              to = line.stations[train.currentSegment+1];
            } else {
              from = line.stations[train.currentSegment+1];
              to = line.stations[train.currentSegment];
            }
            let dx = to.x - from.x, dy = to.y - from.y;
            let x = from.x + dx * train.progress;
            let y = from.y + dy * train.progress;
            let baseOffset = getSegmentOffset(line, train.currentSegment);
            let offset = 6;
            let group = line.trains.filter(t => t.currentSegment === train.currentSegment);
            group.sort((a,b) => a.id - b.id);
            let idx = group.findIndex(t => t.id === train.id);
            let groupOffset = (group.length % 2 === 1)
              ? (idx - Math.floor(group.length/2)) * offset
              : (idx - group.length/2 + 0.5) * offset;
            let totalOffset = baseOffset + groupOffset;
            let len = Math.sqrt(dx*dx + dy*dy);
            let offX = -dy/len * totalOffset;
            let offY = dx/len * totalOffset;
            x += offX;
            y += offY;
            let angle = Math.atan2(dy, dx);
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.fillStyle = "green";
            ctx.fillRect(-trainWidth/2, -trainHeight/2, trainWidth, trainHeight);
            ctx.strokeStyle = "black";
            ctx.strokeRect(-trainWidth/2, -trainHeight/2, trainWidth, trainHeight);
            if(train.onboard && train.onboard.length > 0){
              let n = train.onboard.length;
              let spacing = trainWidth / (n + 1);
              for(let i = 0; i < n; i++){
                let paxOffsetX = -trainWidth/2 + spacing*(i+1);
                let paxOffsetY = 0;
                ctx.beginPath();
                ctx.arc(paxOffsetX, paxOffsetY, 3, 0, 2*Math.PI);
                ctx.fillStyle = "blue";
                ctx.fill();
                ctx.fillStyle = "white";
                ctx.font = "8px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(train.onboard[i].destinationStation.id, paxOffsetX, paxOffsetY);
              }
            }
            ctx.restore();
            let invX = currentMousePos.x - x, invY = currentMousePos.y - y;
            let cos = Math.cos(-angle), sin = Math.sin(-angle);
            let localX = invX * cos - invY * sin;
            let localY = invX * sin + invY * cos;
            if(localX >= -trainWidth/2 && localX <= trainWidth/2 && localY >= -trainHeight/2 && localY <= trainHeight/2){
              hoveredTrain = train;
            }
          }
        }
      }
      // Draw waiting commuters at each station at top-right.
      function drawCommuters(){
        let waitingByStation = {};
        for(let commuter of commuters){
          if(commuter.state === "waiting"){
            let id = commuter.currentStation.id;
            if(!waitingByStation[id]) waitingByStation[id] = [];
            waitingByStation[id].push(commuter);
          }
        }
        for(let stationId in waitingByStation){
          let group = waitingByStation[stationId];
          group.sort((a, b) => a.id - b.id);
          let station = stations.find(s => s.id === stationId);
          // Position passengers to the top-right of the station.
          let baseX = station.x + stationRadius + 5;
          let baseY = station.y - stationRadius - 5;
          let gap = 12;
          for(let i = 0; i < group.length; i++){
            let x = baseX;
            let y = baseY - i * gap;
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, 2*Math.PI);
            ctx.fillStyle = "blue";
            ctx.fill();
            ctx.fillStyle = "red";
            ctx.font = "bold 12px Arial";
            ctx.textAlign = "left";
            ctx.textBaseline = "middle";
            ctx.fillText("→ " + group[i].destinationStation.id, x + 8, y);
          }
        }
      }
      function drawHoveredRoute(){
        if(hoveredCommuter && hoveredCommuter.route){
          ctx.save();
          ctx.strokeStyle = "orange";
          ctx.lineWidth = 3;
          ctx.setLineDash([5,5]);
          for(let seg of hoveredCommuter.route){
            ctx.beginPath();
            ctx.moveTo(seg.from.x, seg.from.y);
            ctx.lineTo(seg.to.x, seg.to.y);
            ctx.stroke();
          }
          ctx.restore();
        }
      }
      function drawArrivalEffects(now){
        for(let i = arrivalEffects.length - 1; i >= 0; i--){
          let effect = arrivalEffects[i];
          let dt = now - effect.startTime;
          let duration = 1000;
          if(dt > duration){
            arrivalEffects.splice(i, 1);
          } else {
            let progress = dt / duration;
            let alpha = 1 - progress;
            let radius = 20 + 20 * progress;
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, radius, 0, 2*Math.PI);
            ctx.strokeStyle = "gold";
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.restore();
          }
        }
      }
      function updateTrainPopup(){
        if(hoveredTrain){
          let list = (hoveredTrain.onboard && hoveredTrain.onboard.length > 0)
                      ? hoveredTrain.onboard.map(p => p.destinationStation.id).join(", ")
                      : "No passengers";
          trainPopup.textContent = "Passengers: " + list;
          trainPopup.style.left = (currentMousePos.x + 15) + "px";
          trainPopup.style.top = (currentMousePos.y + 15) + "px";
          trainPopup.style.display = "block";
        } else {
          trainPopup.style.display = "none";
        }
      }
      // ========= DRAW BACKGROUND =========
      function drawBackground(){
        let gridSpacing = 50;
        ctx.save();
        ctx.strokeStyle = "#e0e0e0";
        ctx.lineWidth = 1;
        for(let x = 0; x <= canvas.width; x += gridSpacing){
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height);
          ctx.stroke();
        }
        for(let y = 0; y <= canvas.height; y += gridSpacing){
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width, y);
          ctx.stroke();
        }
        // Draw some semi-transparent city blocks.
        for(let i = 0; i < 5; i++){
          let bx = Math.random() * canvas.width;
          let by = Math.random() * canvas.height;
          let bWidth = 40 + Math.random() * 60;
          let bHeight = 40 + Math.random() * 60;
          ctx.fillStyle = "rgba(200,200,200,0.3)";
          ctx.fillRect(bx, by, bWidth, bHeight);
        }
        ctx.restore();
      }
      function draw(){
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBackground();
        drawMetroLines();
        drawActiveLine();
        drawStations();
        drawTrains();
        drawCommuters();
        drawHoveredRoute();
        drawArrivalEffects(performance.now());
      }
      function update(now){
        updateTrains(now);
        updateCommuters(now);
        updateTrainPopup();
        draw();
        requestAnimationFrame(update);
      }
      // ========= COMMUTER SPAWN =========
      setInterval(spawnCommuter, commuterSpawnInterval);
      // ========= INITIALIZATION =========
      initStations();
      requestAnimationFrame(update);
    })();
  </script>
</body>
</html>
