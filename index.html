<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Metro System Designer & Simulator</title>
  <style>
    body { font-family: sans-serif; margin:0; padding:0; }
    canvas { border: 1px solid #000; background-color: #f0f0f0; display: block; margin: 0 auto; }
    #controls { margin: 10px; }
    #controls > * { margin-right: 10px; }
    #counter { position: absolute; top: 10px; right: 10px; font-size: 18px; font-weight: bold; background: rgba(255,255,255,0.8); padding: 5px 10px; border: 1px solid #000; }
    #trainPopup {
      position: absolute;
      background: rgba(255,255,255,0.95);
      border: 1px solid #000;
      padding: 5px;
      display: none;
      pointer-events: none;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div id="controls">
    <label for="lineColorDropdown">Line Color:</label>
    <select id="lineColorDropdown">
      <option value="#ff0000" selected>Red</option>
      <option value="#0000ff">Blue</option>
      <option value="#00ff00">Green</option>
      <option value="#ffff00">Yellow</option>
      <option value="#800080">Purple</option>
      <option value="#ffa500">Orange</option>
      <option value="#00ffff">Cyan</option>
      <option value="#ff00ff">Magenta</option>
      <option value="#8b4513">Brown</option>
      <option value="#000000">Black</option>
    </select>
    <button id="newLineButton">New Line</button>
    <button id="deleteLineButton">Delete Line</button>
  </div>
  <div id="counter">Arrived: 0</div>
  <div id="trainPopup"></div>
  <p style="margin:10px;">
    <strong>How to use:</strong><br>
    • Click “New Line” then click on a station to begin drawing a new metro line. As you drag, if you pass near another station the route “snaps” to it. (If the station is already in the route (by ID) it won’t be added again—except if it’s the starting station, which will complete a loop if you have at least two stops.)<br>
    • In modify mode (by clicking an existing segment) drag from the pivot point. Dragging over one of the pivot’s endpoints will remove that stop (allowed even for loop lines or the final station in a non‑loop) as long as at least 2 stops (or 3 for loops) remain; dragging over any other station inserts it between.<br>
    • “Delete Line” removes every line whose color matches the current dropdown selection.<br>
    • Waiting commuters are drawn as small blue circles with a bold red “→ X” label showing their target. Hovering over one highlights its planned route.<br>
    • Passengers board trains—only the train heading toward the next station in their computed route will be accepted. When the train arrives at that station (whether a transfer or final destination) passengers disembark immediately. (If it’s their final destination they trigger a “tada” burst and the global counter increases.)<br>
    • You can mouse over any train to see a popup list of the passengers riding it.<br>
    • Stations are initially placed with a minimum separation.
  </p>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <script>
    (function(){
      // ========= CONFIGURATION =========
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const stationRadius = 15;
      const snapThreshold = 20;
      const trainWidth = 30, trainHeight = 15;
      const dwellTime = 2000;
      const acceleration = 0.0005;
      const maxSpeed = 0.05;
      const commuterSpawnInterval = 3000;
      const stationCount = 20;
      const minStationDist = 80;

      // ========= GLOBAL STATE =========
      let stations = [];  // { id, x, y }
      let metroLines = []; // { id, color, stations: [...], trains: [], isLoop }
      // activeLine is used when drawing a new line or modifying an existing one.
      // In modify mode, we store: editingMode = "modify", modifySegmentIndex, originalStations, modifyCursor, modifyCandidate.
      let activeLine = null;
      // Commuters: { id, currentStation, destinationStation, state:"waiting"|"inTrain", route:[{line, from, to}] }
      let commuters = [];
      let nextLineId = 1, nextTrainId = 1, nextCommuterId = 1;
      let arrivedCount = 0;
      let arrivalEffects = []; // { x, y, startTime }
      let hoveredCommuter = null;
      let hoveredTrain = null; // for train popup
      const trainPopup = document.getElementById('trainPopup');

      // ========= UI ELEMENTS =========
      const lineColorDropdown = document.getElementById('lineColorDropdown');
      const newLineButton = document.getElementById('newLineButton');
      const deleteLineButton = document.getElementById('deleteLineButton');
      const counterDiv = document.getElementById('counter');

      newLineButton.addEventListener('click', () => {
        if(activeLine) return;
        activeLine = {
          id: nextLineId++,
          color: lineColorDropdown.value,
          stations: [],
          trains: [],
          editingMode: "new"
        };
      });

      deleteLineButton.addEventListener('click', () => {
        metroLines = metroLines.filter(line => line.color !== lineColorDropdown.value);
      });

      // ========= INITIALIZE STATIONS =========
      function initStations(){
        const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        let attempts = 0;
        for(let i = 0; i < stationCount; i++){
          let valid = false;
          let s;
          while(!valid && attempts < 1000){
            s = {
              id: letters[i],
              x: Math.random()*(canvas.width-80) + 40,
              y: Math.random()*(canvas.height-80) + 40
            };
            valid = stations.every(st => distance(st.x, st.y, s.x, s.y) >= minStationDist);
            attempts++;
          }
          stations.push(s);
        }
      }

      // ========= HELPER FUNCTIONS =========
      function distance(x1, y1, x2, y2){
        return Math.hypot(x2-x1, y2-y1);
      }
      function getStationAt(x, y){
        for(let s of stations){
          if(distance(x, y, s.x, s.y) < stationRadius) return s;
        }
        return null;
      }
      function getSnappedStation(x, y){
        for(let s of stations){
          if(distance(x, y, s.x, s.y) < snapThreshold) return s;
        }
        return null;
      }
      function getLineSegmentAt(x, y){
        for(let line of metroLines){
          for(let i = 0; i < line.stations.length - 1; i++){
            let a = line.stations[i], b = line.stations[i+1];
            let d = distanceToSegment(x, y, a.x, a.y, b.x, b.y);
            if(d < 5) return { line: line, segmentIndex: i };
          }
        }
        return null;
      }
      function distanceToSegment(px, py, x1, y1, x2, y2){
        const l2 = Math.pow(distance(x1, y1, x2, y2), 2);
        if(l2 === 0) return distance(px, py, x1, y1);
        let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2;
        t = Math.max(0, Math.min(1, t));
        return distance(px, py, x1 + t*(x2-x1), y1 + t*(y2-y1));
      }
      function computeTravelTime(d){
        const t_acc = maxSpeed / acceleration;
        const d_acc = 0.5 * acceleration * t_acc * t_acc;
        if(d >= 2 * d_acc){
          let t_cruise = (d - 2 * d_acc) / maxSpeed;
          return t_acc + t_cruise + t_acc;
        } else {
          return 2 * Math.sqrt(d / acceleration);
        }
      }

      // ========= LINE DRAWING / EDITING =========
      let isDragging = false;
      let currentMousePos = { x: 0, y: 0 };

      canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        let x = e.clientX - rect.left;
        let y = e.clientY - rect.top;
        if(!activeLine){
          let segInfo = getLineSegmentAt(x, y);
          if(segInfo){
            activeLine = segInfo.line;
            activeLine.editingMode = "modify";
            activeLine.modifySegmentIndex = segInfo.segmentIndex;
            activeLine.originalStations = activeLine.stations.slice();
            activeLine.modifyCursor = { x, y };
            activeLine.modifyCandidate = null;
          }
        } else if(activeLine.editingMode === "new"){
          if(activeLine.stations.length === 0){
            let s = getStationAt(x, y);
            if(s) activeLine.stations.push(s);
          }
        }
        isDragging = true;
      });

      canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        currentMousePos.x = e.clientX - rect.left;
        currentMousePos.y = e.clientY - rect.top;
        // Active line drawing/modification
        if(activeLine && isDragging){
          if(activeLine.editingMode === "new"){
            let snapped = getSnappedStation(currentMousePos.x, currentMousePos.y);
            if(snapped){
              let arr = activeLine.stations;
              // Allow loop completion: if snapped equals first station and at least 2 stops exist, add it.
              if(snapped.id === arr[0].id && arr.length >= 2){
                if(arr[arr.length-1].id !== snapped.id) arr.push(snapped);
              } else {
                // If station is already in route...
                if(arr.length > 1 && arr[arr.length-2].id === snapped.id){
                  // Undo last stop.
                  arr.pop();
                } else if(arr.some(s => s.id === snapped.id)){
                  // Otherwise do nothing.
                } else {
                  arr.push(snapped);
                }
              }
            }
          } else if(activeLine.editingMode === "modify"){
            let candidate = getSnappedStation(currentMousePos.x, currentMousePos.y);
            if(candidate){
              activeLine.modifyCursor = { x: candidate.x, y: candidate.y };
              activeLine.modifyCandidate = candidate;
            } else {
              activeLine.modifyCursor = { x: currentMousePos.x, y: currentMousePos.y };
              activeLine.modifyCandidate = null;
            }
          }
        }
        // Hover detection for waiting commuters.
        hoveredCommuter = null;
        let waitingByStation = {};
        for(let commuter of commuters){
          if(commuter.state === "waiting"){
            let id = commuter.currentStation.id;
            if(!waitingByStation[id]) waitingByStation[id] = [];
            waitingByStation[id].push(commuter);
          }
        }
        for(let stationId in waitingByStation){
          let group = waitingByStation[stationId];
          group.sort((a,b) => a.id - b.id);
          let station = stations.find(s => s.id === stationId);
          let spacing = 12;
          for(let i = 0; i < group.length; i++){
            let offset = (i - (group.length - 1)/2) * spacing;
            let pos = { x: station.x + offset, y: station.y };
            if(distance(currentMousePos.x, currentMousePos.y, pos.x, pos.y) < 8){
              hoveredCommuter = group[i];
              break;
            }
          }
          if(hoveredCommuter) break;
        }
      });

      canvas.addEventListener('mouseup', (e) => {
        isDragging = false;
        if(activeLine){
          if(activeLine.editingMode === "modify"){
            let idx = activeLine.modifySegmentIndex;
            let X = activeLine.originalStations[idx];
            let Y = activeLine.originalStations[idx+1];
            // Allow removal if candidate equals one of the endpoints.
            let minStations = activeLine.isLoop ? 3 : 2;
            if(activeLine.modifyCandidate){
              if((activeLine.modifyCandidate.id === X.id || activeLine.modifyCandidate.id === Y.id) 
                 && activeLine.originalStations.length > minStations){
                activeLine.stations = activeLine.originalStations.slice();
                if(activeLine.modifyCandidate.id === X.id){
                  activeLine.stations.splice(idx, 1);
                } else {
                  activeLine.stations.splice(idx+1, 1);
                }
              } else if(activeLine.modifyCandidate.id !== X.id && activeLine.modifyCandidate.id !== Y.id){
                // Insert candidate if not already in route.
                if(!activeLine.originalStations.some(s => s.id === activeLine.modifyCandidate.id)){
                  activeLine.stations = activeLine.originalStations.slice();
                  activeLine.stations.splice(idx+1, 0, activeLine.modifyCandidate);
                } else {
                  activeLine.stations = activeLine.originalStations.slice();
                }
              } else {
                activeLine.stations = activeLine.originalStations.slice();
              }
            }
            activeLine.editingMode = "new";
            activeLine = null;
          }
        }
      });

      canvas.addEventListener('dblclick', (e) => {
        if(activeLine && activeLine.editingMode === "new"){
          if(activeLine.stations.length >= 2){
            // For loop lines, allow completion if first and last stations match.
            if(activeLine.stations[0].id === activeLine.stations[activeLine.stations.length-1].id && activeLine.stations.length >= 3){
              activeLine.isLoop = true;
            } else {
              activeLine.isLoop = false;
            }
            metroLines.push(activeLine);
            spawnDefaultTrains(activeLine);
          }
          activeLine = null;
        }
      });

      // ========= TRAIN SIMULATION =========
      function spawnDefaultTrains(line){
        line.trains = [];
        let now = performance.now();
        if(!line.isLoop){
          line.trains.push({
            id: nextTrainId++,
            line: line,
            direction: 1,
            currentSegment: 0,
            progress: 0,
            state: "dwell",
            dwellStart: now,
            travelTime: 0,
            onboard: []
          });
          line.trains.push({
            id: nextTrainId++,
            line: line,
            direction: -1,
            currentSegment: line.stations.length - 2,
            progress: 0,
            state: "dwell",
            dwellStart: now,
            travelTime: 0,
            onboard: []
          });
        } else {
          let idx1 = 0;
          let idx2 = Math.floor((line.stations.length - 1) / 2);
          line.trains.push({
            id: nextTrainId++,
            line: line,
            direction: 1,
            currentSegment: idx1,
            progress: 0,
            state: "dwell",
            dwellStart: now,
            travelTime: 0,
            onboard: []
          });
          line.trains.push({
            id: nextTrainId++,
            line: line,
            direction: -1,
            currentSegment: idx2,
            progress: 0,
            state: "dwell",
            dwellStart: now,
            travelTime: 0,
            onboard: []
          });
        }
      }

      function updateTrains(now){
        for(let line of metroLines){
          if(line.stations.length < 2) continue;
          for(let train of line.trains){
            if(train.currentSegment < 0) train.currentSegment = 0;
            if(train.currentSegment > line.stations.length - 2) train.currentSegment = line.stations.length - 2;
            let from, to;
            // Determine the arrival station based on train direction.
            if(train.direction === 1){
              from = line.stations[train.currentSegment];
              to = line.stations[train.currentSegment+1];
            } else {
              from = line.stations[train.currentSegment+1];
              to = line.stations[train.currentSegment];
            }
            if(!from || !to) continue;
            let segLength = distance(from.x, from.y, to.x, to.y);
            if(train.state === "dwell"){
              if(now - train.dwellStart >= dwellTime){
                train.travelTime = computeTravelTime(segLength);
                train.state = "moving";
                train.departureTime = now;
              }
            } else if(train.state === "moving"){
              let elapsed = now - train.departureTime;
              let p = elapsed / train.travelTime;
              let ease = 0.5 - 0.5 * Math.cos(Math.PI * Math.min(p, 1));
              train.progress = ease;
              if(p >= 1){
                // Determine arrival station (the station we are moving toward).
                let arrivalStation = (train.direction === 1) ? line.stations[train.currentSegment+1] : line.stations[train.currentSegment];
                // Disembark passengers whose next route segment’s "to" equals arrivalStation.
                train.onboard.forEach(commuter => {
                  if(commuter.route && commuter.route.length > 0 && commuter.route[0].to.id === arrivalStation.id){
                    commuter.currentStation = arrivalStation;
                    commuter.route.shift();
                    if(commuter.destinationStation.id === arrivalStation.id){
                      commuter.arrived = true;
                      arrivedCount++;
                      arrivalEffects.push({ x: arrivalStation.x, y: arrivalStation.y, startTime: now });
                    } else {
                      commuter.state = "waiting";
                    }
                  }
                });
                train.onboard = [];
                // Update train position.
                if(!line.isLoop){
                  if(train.direction === 1 && train.currentSegment === line.stations.length - 2){
                    // At the end: remain at last station and reverse direction.
                    train.direction = -1;
                  } else if(train.direction === -1 && train.currentSegment === 0){
                    train.direction = 1;
                  } else {
                    train.currentSegment += train.direction;
                  }
                } else {
                  train.currentSegment = (train.currentSegment + train.direction) % (line.stations.length - 1);
                  if(train.currentSegment < 0) train.currentSegment += (line.stations.length - 1);
                }
                train.state = "dwell";
                train.dwellStart = now;
                train.progress = 0;
              }
            }
          }
        }
      }

      // ========= COMMUTER SIMULATION =========
      function buildGraph(){
        let graph = {};
        for(let s of stations) graph[s.id] = [];
        for(let line of metroLines){
          for(let i = 0; i < line.stations.length - 1; i++){
            let a = line.stations[i], b = line.stations[i+1];
            graph[a.id].push({ station: b, line: line });
            graph[b.id].push({ station: a, line: line });
          }
        }
        return graph;
      }

      function computeRoute(start, goal){
        let graph = buildGraph();
        let queue = [ start ];
        let visited = {};
        visited[start.id] = null;
        while(queue.length){
          let current = queue.shift();
          if(current === goal) break;
          for(let edge of graph[current.id]){
            if(!(edge.station.id in visited)){
              visited[edge.station.id] = { from: current, line: edge.line };
              queue.push(edge.station);
            }
          }
        }
        if(!(goal.id in visited)) return null;
        let route = [];
        let cur = goal;
        while(cur !== start){
          let info = visited[cur.id];
          route.unshift({ from: info.from, to: cur, line: info.line });
          cur = info.from;
        }
        return route;
      }

      function spawnCommuter(){
        if(stations.length < 2) return;
        let start = stations[Math.floor(Math.random()*stations.length)];
        let dest;
        do {
          dest = stations[Math.floor(Math.random()*stations.length)];
        } while(dest === start);
        let route = computeRoute(start, dest);
        let commuter = {
          id: nextCommuterId++,
          currentStation: start,
          destinationStation: dest,
          state: "waiting",
          route: route
        };
        commuters.push(commuter);
      }

      function updateCommuters(now){
        // Recalculate routes for waiting commuters.
        for(let commuter of commuters){
          if(commuter.state === "waiting"){
            if(commuter.currentStation.id === commuter.destinationStation.id){
              commuter.arrived = true;
              arrivedCount++;
              arrivalEffects.push({ x: commuter.currentStation.x, y: commuter.currentStation.y, startTime: now });
              continue;
            }
            commuter.route = computeRoute(commuter.currentStation, commuter.destinationStation);
            if(commuter.route && commuter.route.length > 0){
              let seg = commuter.route[0];
              // Board only if candidate train is dwelling at current station and its next stop matches seg.to.
              let candidate = seg.line.trains.find(train => {
                if(train.state !== "dwell") return false;
                let posStation = (train.direction === 1) ? train.line.stations[train.currentSegment] : train.line.stations[train.currentSegment+1];
                if(posStation.id !== commuter.currentStation.id) return false;
                if(train.direction === 1){
                  return train.line.stations[train.currentSegment+1].id === seg.to.id;
                } else {
                  return train.line.stations[train.currentSegment].id === seg.to.id;
                }
              });
              if(candidate){
                commuter.state = "inTrain";
                candidate.onboard = candidate.onboard || [];
                candidate.onboard.push(commuter);
              }
            }
          }
        }
        commuters = commuters.filter(c => !c.arrived && c.currentStation.id !== c.destinationStation.id);
        counterDiv.textContent = "Arrived: " + arrivedCount;
      }

      // ========= DRAWING FUNCTIONS =========
      function getSegmentOffset(line, segmentIndex){
        let a = line.stations[segmentIndex], b = line.stations[segmentIndex+1];
        let sameSegmentLines = metroLines.filter(l => {
          for(let i = 0; i < l.stations.length - 1; i++){
            let p = l.stations[i], q = l.stations[i+1];
            if((p.id === a.id && q.id === b.id) || (p.id === b.id && q.id === a.id)) return true;
          }
          return false;
        });
        sameSegmentLines.sort((l1, l2) => l1.id - l2.id);
        let idx = sameSegmentLines.findIndex(l => l.id === line.id);
        let count = sameSegmentLines.length;
        let offsetDistance = 10;
        let offset = (count % 2 === 1)
          ? (idx - Math.floor(count/2)) * offsetDistance
          : (idx - count/2 + 0.5) * offsetDistance;
        return offset;
      }

      function drawStations(){
        for(let s of stations){
          ctx.beginPath();
          ctx.arc(s.x, s.y, stationRadius, 0, 2*Math.PI);
          ctx.fillStyle = "#FFF";
          ctx.fill();
          ctx.strokeStyle = "#000";
          ctx.stroke();
          ctx.fillStyle = "#000";
          ctx.font = "12px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(s.id, s.x, s.y);
        }
      }

      function drawMetroLines(){
        for(let line of metroLines){
          ctx.beginPath();
          ctx.lineWidth = 4;
          ctx.strokeStyle = line.color;
          for(let i = 0; i < line.stations.length - 1; i++){
            let s1 = line.stations[i];
            let s2 = line.stations[i+1];
            let offset = getSegmentOffset(line, i);
            let dx = s2.x - s1.x, dy = s2.y - s1.y;
            let len = Math.sqrt(dx*dx + dy*dy);
            let offX = -dy/len * offset;
            let offY = dx/len * offset;
            let startX = s1.x + offX;
            let startY = s1.y + offY;
            let endX = s2.x + offX;
            let endY = s2.y + offY;
            if(i === 0) ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
          }
          ctx.stroke();
          ctx.lineWidth = 2;
        }
      }

      function drawActiveLine(){
        if(activeLine){
          if(activeLine.editingMode === "new"){
            ctx.beginPath();
            ctx.lineWidth = 4;
            ctx.strokeStyle = activeLine.color;
            for(let i = 0; i < activeLine.stations.length; i++){
              let s = activeLine.stations[i];
              if(i === 0) ctx.moveTo(s.x, s.y);
              else ctx.lineTo(s.x, s.y);
            }
            if(activeLine.stations.length > 0){
              ctx.lineTo(currentMousePos.x, currentMousePos.y);
            }
            ctx.stroke();
            ctx.lineWidth = 2;
          } else if(activeLine.editingMode === "modify"){
            ctx.save();
            ctx.globalAlpha = 0.3;
            ctx.beginPath();
            ctx.strokeStyle = activeLine.color;
            for(let i = 0; i < activeLine.originalStations.length; i++){
              let s = activeLine.originalStations[i];
              if(i === 0) ctx.moveTo(s.x, s.y);
              else ctx.lineTo(s.x, s.y);
            }
            ctx.stroke();
            ctx.restore();
            let tempStations = activeLine.originalStations.slice();
            let idx = activeLine.modifySegmentIndex;
            tempStations.splice(idx+1, 0, activeLine.modifyCursor);
            ctx.beginPath();
            ctx.lineWidth = 4;
            ctx.strokeStyle = activeLine.color;
            for(let i = 0; i < tempStations.length; i++){
              let p = tempStations[i];
              if(i === 0) ctx.moveTo(p.x, p.y);
              else ctx.lineTo(p.x, p.y);
            }
            ctx.stroke();
            ctx.lineWidth = 2;
          }
        }
      }

      function drawTrains(){
        hoveredTrain = null;
        for(let line of metroLines){
          for(let train of line.trains){
            let from, to;
            if(train.direction === 1){
              from = line.stations[train.currentSegment];
              to = line.stations[train.currentSegment+1];
            } else {
              from = line.stations[train.currentSegment+1];
              to = line.stations[train.currentSegment];
            }
            let dx = to.x - from.x, dy = to.y - from.y;
            let x = from.x + dx * train.progress;
            let y = from.y + dy * train.progress;
            let baseOffset = getSegmentOffset(line, train.currentSegment);
            let offset = 6;
            let group = line.trains.filter(t => t.currentSegment === train.currentSegment);
            group.sort((a,b) => a.id - b.id);
            let idx = group.findIndex(t => t.id === train.id);
            let groupOffset = (group.length % 2 === 1)
              ? (idx - Math.floor(group.length/2)) * offset
              : (idx - group.length/2 + 0.5) * offset;
            let totalOffset = baseOffset + groupOffset;
            let len = Math.sqrt(dx*dx + dy*dy);
            let offX = -dy/len * totalOffset;
            let offY = dx/len * totalOffset;
            x += offX;
            y += offY;
            let angle = Math.atan2(dy, dx);
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.fillStyle = "green";
            ctx.fillRect(-trainWidth/2, -trainHeight/2, trainWidth, trainHeight);
            ctx.strokeStyle = "black";
            ctx.strokeRect(-trainWidth/2, -trainHeight/2, trainWidth, trainHeight);
            if(train.onboard && train.onboard.length > 0){
              let n = train.onboard.length;
              let spacing = trainWidth / (n + 1);
              for(let i = 0; i < n; i++){
                let paxOffsetX = -trainWidth/2 + spacing*(i+1);
                let paxOffsetY = 0;
                ctx.beginPath();
                ctx.arc(paxOffsetX, paxOffsetY, 3, 0, 2*Math.PI);
                ctx.fillStyle = "blue";
                ctx.fill();
                ctx.fillStyle = "white";
                ctx.font = "8px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(train.onboard[i].destinationStation.id, paxOffsetX, paxOffsetY);
              }
            }
            ctx.restore();
            // Check mouse-over for train popup.
            let invX = currentMousePos.x - x, invY = currentMousePos.y - y;
            let cos = Math.cos(-angle), sin = Math.sin(-angle);
            let localX = invX * cos - invY * sin;
            let localY = invX * sin + invY * cos;
            if(localX >= -trainWidth/2 && localX <= trainWidth/2 && localY >= -trainHeight/2 && localY <= trainHeight/2){
              hoveredTrain = train;
            }
          }
        }
      }

      function drawCommuters(){
        let waitingByStation = {};
        for(let commuter of commuters){
          if(commuter.state === "waiting"){
            let id = commuter.currentStation.id;
            if(!waitingByStation[id]) waitingByStation[id] = [];
            waitingByStation[id].push(commuter);
          }
        }
        for(let stationId in waitingByStation){
          let group = waitingByStation[stationId];
          group.sort((a, b) => a.id - b.id);
          let spacing = 12;
          let station = stations.find(s => s.id === stationId);
          for(let i = 0; i < group.length; i++){
            let offset = (i - (group.length - 1)/2) * spacing;
            let x = station.x + offset;
            let y = station.y;
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, 2*Math.PI);
            ctx.fillStyle = "blue";
            ctx.fill();
            ctx.fillStyle = "red";
            ctx.font = "bold 12px Arial";
            ctx.textAlign = "left";
            ctx.textBaseline = "middle";
            ctx.fillText("→ " + group[i].destinationStation.id, x + 8, y - 10);
          }
        }
      }

      function drawHoveredRoute(){
        if(hoveredCommuter && hoveredCommuter.route){
          ctx.save();
          ctx.strokeStyle = "orange";
          ctx.lineWidth = 3;
          ctx.setLineDash([5,5]);
          for(let seg of hoveredCommuter.route){
            ctx.beginPath();
            ctx.moveTo(seg.from.x, seg.from.y);
            ctx.lineTo(seg.to.x, seg.to.y);
            ctx.stroke();
          }
          ctx.restore();
        }
      }

      function drawArrivalEffects(now){
        for(let i = arrivalEffects.length - 1; i >= 0; i--){
          let effect = arrivalEffects[i];
          let dt = now - effect.startTime;
          let duration = 1000;
          if(dt > duration){
            arrivalEffects.splice(i, 1);
          } else {
            let progress = dt / duration;
            let alpha = 1 - progress;
            let radius = 20 + 20 * progress;
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, radius, 0, 2 * Math.PI);
            ctx.strokeStyle = "gold";
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.restore();
          }
        }
      }

      function updateTrainPopup(){
        if(hoveredTrain){
          let list = (hoveredTrain.onboard && hoveredTrain.onboard.length > 0)
                    ? hoveredTrain.onboard.map(p => p.destinationStation.id).join(", ")
                    : "No passengers";
          trainPopup.textContent = "Passengers: " + list;
          trainPopup.style.left = (currentMousePos.x + 15) + "px";
          trainPopup.style.top = (currentMousePos.y + 15) + "px";
          trainPopup.style.display = "block";
        } else {
          trainPopup.style.display = "none";
        }
      }

      function draw(){
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawMetroLines();
        drawActiveLine();
        drawStations();
        drawTrains();
        drawCommuters();
        drawHoveredRoute();
        drawArrivalEffects(performance.now());
      }

      function update(now){
        updateTrains(now);
        updateCommuters(now);
        updateTrainPopup();
        draw();
        requestAnimationFrame(update);
      }

      // In updateTrains, disembark passengers immediately upon arrival.
      // When a train completes its movement (p>=1), determine its arrival station,
      // then for each onboard commuter, if the next route segment’s destination equals that station,
      // set their current station to that station, remove that segment from their route, and mark them as arrived (if final) or waiting.
      // Then update train position and reset state.
      // (This logic is included in the updateTrains() function above in the p>=1 block.)
      
      // ========= COMMUTER SIMULATION =========
      function buildGraph(){
        let graph = {};
        for(let s of stations) graph[s.id] = [];
        for(let line of metroLines){
          for(let i = 0; i < line.stations.length - 1; i++){
            let a = line.stations[i], b = line.stations[i+1];
            graph[a.id].push({ station: b, line: line });
            graph[b.id].push({ station: a, line: line });
          }
        }
        return graph;
      }

      function computeRoute(start, goal){
        let graph = buildGraph();
        let queue = [ start ];
        let visited = {};
        visited[start.id] = null;
        while(queue.length){
          let current = queue.shift();
          if(current === goal) break;
          for(let edge of graph[current.id]){
            if(!(edge.station.id in visited)){
              visited[edge.station.id] = { from: current, line: edge.line };
              queue.push(edge.station);
            }
          }
        }
        if(!(goal.id in visited)) return null;
        let route = [];
        let cur = goal;
        while(cur !== start){
          let info = visited[cur.id];
          route.unshift({ from: info.from, to: cur, line: info.line });
          cur = info.from;
        }
        return route;
      }

      function spawnCommuter(){
        if(stations.length < 2) return;
        let start = stations[Math.floor(Math.random()*stations.length)];
        let dest;
        do {
          dest = stations[Math.floor(Math.random()*stations.length)];
        } while(dest === start);
        let route = computeRoute(start, dest);
        let commuter = {
          id: nextCommuterId++,
          currentStation: start,
          destinationStation: dest,
          state: "waiting",
          route: route
        };
        commuters.push(commuter);
      }

      function updateCommuters(now){
        for(let commuter of commuters){
          if(commuter.state === "waiting"){
            if(commuter.currentStation.id === commuter.destinationStation.id){
              commuter.arrived = true;
              arrivedCount++;
              arrivalEffects.push({ x: commuter.currentStation.x, y: commuter.currentStation.y, startTime: now });
              continue;
            }
            commuter.route = computeRoute(commuter.currentStation, commuter.destinationStation);
            if(commuter.route && commuter.route.length > 0){
              let seg = commuter.route[0];
              let candidate = seg.line.trains.find(train => {
                if(train.state !== "dwell") return false;
                let posStation = (train.direction === 1) ? train.line.stations[train.currentSegment] : train.line.stations[train.currentSegment+1];
                if(posStation.id !== commuter.currentStation.id) return false;
                if(train.direction === 1){
                  return train.line.stations[train.currentSegment+1].id === seg.to.id;
                } else {
                  return train.line.stations[train.currentSegment].id === seg.to.id;
                }
              });
              if(candidate){
                commuter.state = "inTrain";
                candidate.onboard = candidate.onboard || [];
                candidate.onboard.push(commuter);
              }
            }
          }
        }
        commuters = commuters.filter(c => !c.arrived && c.currentStation.id !== c.destinationStation.id);
        counterDiv.textContent = "Arrived: " + arrivedCount;
      }

      // ========= INITIALIZATION =========
      initStations();
      setInterval(spawnCommuter, commuterSpawnInterval);
      requestAnimationFrame(update);
    })();
  </script>
</body>
</html>
